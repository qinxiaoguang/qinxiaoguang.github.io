#+TITLE: 关于协程

* 概述
在学了golang后，很喜欢其中的协程goroutine,对其实现方式也很有兴趣，经常思考，一个cpu内核开一个线程，是怎么对这些个协程进行调度的，所以去看了下源码，发现并不是很容易看懂，网上搜了很多文章，也不知其所以然，所以就又去看async/await的实现方法，在看async之前，一直以为协程就是轻量级线程，类似golang中的那样，但是看过async之后，总觉得async的用法怪怪得，跟golang的goroutine完全不一样，后来才发现是自己的理解有问题。
* 什么是协程
协程是轻量级线程，其调度是在用户态完成的，及不是内核态或者说不是操作系统自己做的调度。
这里可以简单记录下三者的区别,首先有知道进程的调度是跟时间片有关的，这个是os关心的事情，只要知道os做了很多,进程很难被饿死就对了。不要限入了，某个进程会一直执行的思维里去了。
1. 进程是在调度的时候必须进入内核态，其由操作系统进行调度，其有独立的上下文(PCB,process control blcok)，保存当前进程执行的上下文环境，有独立的地址空间，在调度的时候切换上下文会占用资源，所以其调度的花费时间较长。
2. 线程是轻量级进程，一个进程里可以有多个线程，且共享该进程中的所有资源，每个线程又有自己的执行堆栈等信息，但没有独立的地址空间，线程在调度的时候切换上下文环境开销比进程小。
3. 线程通常也分为用户线程和内核线程，内核线程通常是内核自己创建出来的线程，也叫守护线程，但内核线程只工作在内核态，没有用户空间，
4. 进程是资源分配的最小单位，线程是程序执行的最小单位。
5. 一个程序至少有一个进程，一个进程至少有一个线程(main),线程是进程里的一个执行单元,也是进程内的可调度的实体。一个线程挂掉，将导致整个进程挂掉。
6. 进程间通信需要通过IPC的方式，此种方式有很多，如管道，信号量等，而同一进程下的线程通信可以通过共享变量等手段.
7. 协程是由用户态线程进行调度。其核心思想 **控制流的主动让出和恢复** (yield,await等),必须在单线程中运行。golang中的gorotine其实严格来说并不是协程，而是另一种线程。
8. 一般来说协程分为无栈协程(stackless)和有栈协程(stackful)，如python中的aysnc/await就属于无栈协程，而golang中的go func属于有栈协程。有栈其实就是在调度的时候将栈中的内容全部保存下来，所以可以将其看成另一种线程,或者用户态线程。

我自己还纳闷，golang里，一个线程里不开辟新的空间，不替换寄存器的时候，单条流运行到底是怎么实现多个协程的调度的，现在算是明白了一点。

* 参考
https://jiajunhuang.com/articles/2018_04_03-coroutine.md.html
