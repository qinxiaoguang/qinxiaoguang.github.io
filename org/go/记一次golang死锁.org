#+TITLE: 记一次golang死锁

* 概述 
一般来说常见的死锁形式是互锁，简单来说就是每个人都有两把锁，第一个人先锁a,再锁b,第二个人先锁b再锁a, 而两个人都卡在了第二步，就造成了死锁，但是还有一些隐含死锁非常难找到。比如今天遇到的这一种。

使用的是读写锁。
读写锁的含义就是，进行读操作的时候，不能进行写，但可以多个读同时进行，而进行写操作的时候不能进行读，且只允许有一个写操作。这样的读写锁在golang里面是用 =sync.RWMutex= 来表示，其中的 =Lock= 方法就是写锁，而 =RLock= 是读锁。
考虑你调用了下面的方法:
#+BEGIN_SRC go
rwLock := sync.RWMutex{}
go rwLock.RLock()
time.Sleep(time.Second)
go rwLock.RLock()
time.Sleep(time.Millisecond)
go rwLock.Lock()
time.Sleep(time.Second)
go rwLock.RLock()
#+END_SRC
你认为这个读锁能通过几次呢？
也有可能是我知识水平够，只记住了多个读操作可以同时运行，所以可能会认为有3个读操作会同时通过，但其实不然，当读锁未释放，而有写锁到来时，该写锁后续的所有读锁都不会被通过，而是被阻塞。
就是这个简单的道理，很容易造成死锁。比如以下伪代码场景:
#+BEGIN_SRC go
A 线程
=========
x.Lock
y.RLock: 第三个阻塞
=========
B 线程
=========
y.RLock
x.Lock : 第一个阻塞
=========
C 线程
=========
y.Lock : 第二个阻塞
=========
#+END_SRC
不要问代码为什么这么写，因为特殊需要。
避免这种死锁的方式，就是同一资源少用两个锁，即便是读写锁。如果非要用读写锁，那么考虑在使用两个锁的时候，不要进行交叉锁，即 a.lock -> b.lock -> a.unlock, 这种形式的锁尽量避免，优化方向考虑解决交叉锁。
