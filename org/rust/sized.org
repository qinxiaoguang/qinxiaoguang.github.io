#+TITLE: sized与?sized

* 解释
rust在编译时就要知道类型的实际大小。而很多类型只有在运行时才能确定大小，如"str"类型及部分trait。

像这些在编译时不能确定其大小的类型，叫动态大小类型。其有一个黄金规则:必须将动态大小类型的值置于某种指针之后。如str类型不能直接被创建，像代码 =let s:str = "aaa"= 是不被允许的，但可以将其放在指针后,如 =let s:&str = "aaa"= ,当然智能指针也是指针的一种，所以Box<str>,Rc<str>也是合法的。

Rust 有一个特定的 trait 来决定一个类型的大小是否在编译时可知，这就是Sized, 其表示某个类型在编译器能确定大小。Rust 隐式的为每一个泛型函数增加了 =Sized bound=, 即 =fn test<T>(t:T)= 会被自动编译为 =fn test<T:Sized>(t:T)=, 而与 =Sized= 相对立的还有一个类型是 =?Sized=, 这种语法只能用在 =Sized= 上，其表示对应的类型可能是 =Sized= 也可能不是。所以对于 =?Sized= 类型来说，在泛型函数上，只能将类型用在指针后，因为在编译时不确定其类型大小，即 =fn test<T:?Sized>test(t:&T)=
