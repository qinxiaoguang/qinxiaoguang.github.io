#+TITLE: leetcode题解
* 概述
过于简单的题，就不记录了
* 0002
题目大意
#+BEGIN_VERSE
计算两个链表的和，如1->2->3 + 2->4->6 = 3->6->9
#+END_VERSE

解决要点
#+BEGIN_VERSE
使用一个临时变量来保存其中的进位
#+END_VERSE

* 0003
题目大意
#+BEGIN_VERSE
字符串中的最长无重复子串，如abcbcaa ,最长无重复子串是 abc
#+END_VERSE

解决要点
#+BEGIN_VERSE
使用start,end两个指针来进行遍历，遍历的时候，只需要end依次往后移动，start不动，同时需要使用一个hashmap来记录当前最后一个出现的字母的位置，如abcb,遍利到c时，hashmap中的值是[a]=0,[b]=1,[c]=2,那么在每次遍利的时候，都要查询hashmap中是否存在当前字母，如果存在，则计算目前遍利的最长子串的长度，并将start放在当前位置，end继续往后遍历，同时更新hashmap中出现的重复的字母的位置。这样整个时间复杂度为o(n)。
#+END_VERSE
* 0004
题目大意
#+BEGIN_VERSE
有两个有序数组，求这两个有序数组的中位数，如果中位数有两个，则求这两个数的平均。如: [1,2], [3]的中位数是2, [1,2],[3,4]的中位数是 (2+3)/2 = 2,要求时间复杂度是log(m+n)
#+END_VERSE

解决要点
#+BEGIN_VERSE
题中要求时间复杂度是log(m+n)所以其一定是使用二分的方法进行解决，该题的主旨是求第k大的数，其中k=(m+n)/2,比较两个中位数的大小，假设第一个数组的中位数小于第二个数组的中位数，如果当前两个数组的总长度-第一个数组到中位数的长度 依然比k大，那么第k大的数就一定不在第一个数组的中位数左边的数中，所以可以将第一个数组中位数左边的数排除掉，依次类推。
#+END_VERSE

* 0005
求最大回文子串
解:
#+BEGIN_VERSE
1. 暴力,从每个串的中心往两边遍历。计算最大值。但是如果是偶数个数，就需要在每两个数之间填充一个字符。为了方便，无论是奇数还是偶数，都往其填字符,无论两个数之间还是两边，都填相同的字符，这样最终的字符串一定是奇数个，如 123 -> #1#2#3# ， 1234 -> #1#2#3#4#。时间复杂度O(n^2)
2. dp, 注意不要把其类比为两个字符串的最大公共子串，完全不相关！使用dp的方式为，若dp[i][j]为回文串，那么dp[i+1][j-1]也是回文, 所以有，~if s[i] == s[j] : dp[i][j] == (true && dp[i+1][j-1])~  时间复杂度O(n^2)
3. Manacher方法,与第一种方法类似，从中心点遍历，但是该方法的要点是利用到之前已经得到的回文串信息进行遍历，设rl[i]为当前点最大回文半径，回文半径就是以当前点为中心的回文长度的一半+1,那么这个问题就是求rl[i]的所有值，那么如何求rl[i]呢，假设当前遍历到了i点，并设mx为当前知道的所有回文串中最靠右的串(不是最大回文串)，而mid则是最靠右的回文串的中心点。那么如果i>=mx,则只能从中心往外扩展，而若i<mx,则可以使用到i关于mid的对称点(j)的信息，因为rl[j]的值已经求出，那么rl[i]>=r[j],如果i到mx的长度大于r[j]则，必然有r[i]=r[j],否则在r[j]的基础上继续向外边扩展。
#+END_VERSE
manacher方法参考:https://segmentfault.com/a/1190000003914228 、https://www.felix021.com/blog/read.php?2040
* 0006
求zigzag的水平方向字符串。
如:
#+BEGIN_VERSE
"abcdefghijklmn"的zigzag图如下
a    g    m
b  f h  l n
c e  i k  
d    j
那么他的水平方向字符串为: "agmbfhlnceikdj"
#+END_VERSE
解:
#+BEGIN_VERSE
其实把字符串的下标写出来:
1     7       13
2   6 8    12 14
3 5   9  11
4     10
是可以发现其中的规律的。
假设有n行，那么第i行的水平字符串的规律为: prefix+ 2*(n-i) 或 prefix + 2*(i-1),其实就是交替加上数值2*(n-i)和2*(i-1),但是要注意，如果n-i或者i-1为0，则跳过。
#+END_VERSE
* 0010
模仿正则的题，输入的正则匹配串只有a-z及 =*.= ，其中 =*= 表示匹配0到多个， =.= 匹配1个
解:
#+BEGIN_VERSE
1. 有向状态自动机，采用dfs或者bfs的方式或者递归进行解，但时间复杂度比较大。
2. 二维dp来解:dp[i][j]表示s[0,i)与p[0,j)是否match，那么dp[i][j]的更新规则则为:
- ~dp[i][j] = dp[i-1][j-1], if p[j-1]!= "*" && (s[i-1] == p[j-1] || p[j-1] == '.')~ 如果s[i],p[j]相等，或者p[j]是符号.，则dp[i+1][j+1]=dp[i-1][j-1]
- ~dp[i][j] = dp[i][j-2], if p[j-1] == "*" and pattern repeats for 0 times~ 如果当前p点是*符号，并且没有被匹配过，则dp[i+1][j+1]=dp[i+1][j-1]，因为*可以匹配0次。
- ~dp[i][j] = dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == "."), if p[j-1] == "*" and the pattern repeats for at least 1 times~ 如果当前点是*且被匹配1次以上，那么dp[i+1][j+1] = dp[i][j+1] && (s[i]==p[j-1] || p[j-1] = .)
其实大白话就分3种情况，当前点是字母，当前点是.,当前点是*等。
#+END_VERSE
* 0011
给定一个数组，数组中的每个点的数表示该点中线段的高，计算哪两个线段围成的矩形面积最大。数组中每相邻两个点的距离为1
解：
#+BEGIN_VERSE
使用i,j两个指针，分别指向数组首尾，并记录当前ij围成的面积是否最大，更新当前面积最大值，若arr[i]<arr[j]，则i右移即i++,否则j--.
该题巧妙在，i,j指针中的最小值是面积的极限，所有如果arr[i]<arr[j],移动j没有意义，即(i,j-1)不会比(i,j)大,所有只能移动i来更新面积大小。
#+END_VERSE

* 0014
题目是求多个串的最长公共前缀,如"abc","a","ab"的最长公共前缀是"a"
解:
#+BEGIN_VERSE
1. 暴力解，复杂度o(n^2)
2. 看起来此题很简单，但是实际还有更好的解法。先用一个最短的字符串做基准，让他依次与后边的所有串比较，被比较的串截取成与该最短串长度一样，并对比是否相等，若相等，则比较下一个，否则找出这两个串中的最长公共前缀串，方法是暴力，并用他更新当前的基准串。依次类推。该种方法的巧妙之处在于，不是一个字符一个字符的比较，而是多个字符一起比较。
#+END_VERSE
* 0015
找一个数组中所有的3个数加起来等于0的数
解:
#+BEGIN_VERSE
1. 暴力解o(n^3),超时
2. 先对数组排序，遍历该数组，遍历到i个数时，即求i后的数组中的两个数加起来等于arr[i]的负数。则题目变为求一个有序数组中加起来等于某数的两个数。解决其问题的思路是使用两个指针(i,j)，分别指向前后，如果两个指针的数加起来比目标值大，则j--, 否则i++,原因在于j--使得两个数减小，i++使得两个数变大。
#+END_VERSE
* 0020
求([{}])这些字符组成的字符串是否合法，合法的规则是每个括号都能正确匹配。
解:
#+BEGIN_VERSE
使用栈即可
#+END_VERSE
* 0022
给n对括号，生成不同的合法的括号组，如 =(())= 生成 =(())、()()、= 等
解:
#+BEGIN_VERSE
通过暴力搜索+剪枝的方法，每个点只有两个选择，要么加左括号，要么加右括号。其中加的时候必须有:
1. 左括号数目大于右括号
2. 当前还有剩余括号。
#+END_VERSE
* 0023
merge k个排序好的链表
解:
#+BEGIN_VERSE
1. 一个一个的依次merge
2. 使用小顶堆，将数据依次入队，并取出，O(mlogm),m是所有数据的长度
3. 使用小顶堆，不过每次入堆的数据是当前每个链表的头，入完一次后，取数据，取完后，将该数据的后边的数据再入堆，再取，依次类推。
4. 归并，分而治之，最后治理的是两个链表，就变成了merge两个链表的问题了。
#+END_VERSE
参考:https://liweiwei1419.github.io/leetcode-solution/leetcode-0023-merge-k-sorted-lists/
* 0025
给一个链表和k,每k个节点为一组进行反转，不足k的不反转，如 =1->2->3->4->5= ,在k=3时 =3->2->1->4->5=,其中0024是在k=2的时候的特例题，这里就汇总到一起。
解:
#+BEGIN_VERSE
使用两个指针，一个head一个tail,分别表示当前反转中的链表的head和tail,那么下一步就是将tail指向tail.next.next,而tail.next指向head,并同时将head更新为tail.next,并注意处理当前反转的长度是否到了k.
#+END_VERSE
* 0027
0026和0027基本是同一个类型的题，其中0026是将一个有序数组中的每个数都变为不重复的数，并返回其长度，而0027是将一个数组中的指定的值的数去掉，并返回其长度。但是两个题目中的要求都是，需要改变原有的数组结构，即删除就是真正删除。如[1,2,2,3]应该返回[1,2,3].
解:
#+BEGIN_VERSE
解决思路其实挺简单，就是使用两个变量，一个i,一个j,其中i表示当前遍历的点，j表示当前数组应填充的位置。依次往后遍历即可。
#+END_VERSE
* 0029
不使用乘法和除法实现除法。(非取余)
解:
#+BEGIN_VERSE
使用左移来操作，如x,y两个值，每次左移y，判断x是否比y大，如果大，则最终解必定比2^n大，如果小，则x=x-2^(n-1)，继续使用左移操作。
如代码:
#+END_VERSE

代码:
#+BEGIN_SRC go
func solve(x, y int) int {
    res := 0
    n := getMinN(x, y)
    for n >= 0 {
        res += int(math.Pow(float64(2), float64(n)))
        x -= (y << uint(n))
        n = getMinN(x, y)
    }
    return res
}

// 计算y * 2^n < x中N的最大值
func getMinN(x, y int) int {
    n := 0
    for x-y >= 0 {
        n += 1
        y <<= 1
    }
    return n - 1
}
#+END_SRC
* 0030
给定一个字符串s,并给一个长度相同的字符串数组，在 s 中找出可以恰好串联 words 中所有单词的子串的起始位置。
如s="barfoothefoobarman", arr=["foo","bar"],那么结果为[0,9],即s[0]的位置有barfoo,能够串联arr中的字符串，s[9]的位置是foobar,同样能串联。
解:
#+BEGIN_VERSE
刚开始考虑使用将arr中的字符串进行全排列后进行查找，但是这种方法复杂度过大，于是放弃。
在网上查找资料，发现了一个比较好的方案，使用滑动窗口来解决，需要注意的是，数组中的字符串，每个字符串的长度都想同,这是一个很重要的信息。解决方案如下：
假设数组中的每个单词长度为l。
将数组中的单词放入一个map<string,int>中，其中value是此单词出现的数量。
从s的开头依次往后遍历,遍历到l-1处。
从当前的遍历点开始，使用滑动窗口的思想进行查找。
以步长为l的方式往后查找，并使用两个指针，记录当前的滑动窗口，若当前步长宽度的单词在map中，则将此map中的对应的单词数量减1，若map中对应的该单词数量减1后的结果小于0，则以步长l向后移动滑动窗口的头指针，即将滑动窗口中的头部数据排出，同时更新map中的值，直到map中所有的单词数量>=0,若map中所有的单词对应的结果为0，则当前滑动窗口的值就串联了所有的arr中的单词。以此种方式一次往后查找，直到找到末尾。(细节处理就不说了，只说方法,总结来说，就是进行l次滑动窗口)
时间复杂度是o(l*(n/l)) = o(n)
#+END_VERSE
* 0031
给定一个排列的数字串，计算该串的下一个比当前更大的排列(即字母排序中的下一个排列)，如123->132, 231->312
解:
#+BEGIN_VERSE
该题是有规律的，规律是，从右往前遍历，找到第一个非升序的点，如123，第一个非升序的点就是2，那么将其后边比他大的最小点与他进行交换，交换完毕后，将此点后的所有数字重新排列(即从前到后升序排列即可)
如1354,先找到非升序的点是3，那么3后边比3大的最小点是4，将3和4交换位置，变为1453，同时将3原来的位置后边的数字，即53，进行重新排列，变为35，那么最终结果就是1435.
#+END_VERSE
* 0032
给出一个由 =()= 括号组成的字符串，计算其中的合法的字符串的最长长度。如 =(()= 为2， =()())= 为4.
解:
#+BEGIN_VERSE
1. 使用栈辅助以及两个指针(前后,来表示当前遍历的合法数据)，从头往后遍历，若为 =(= 则入栈，若为 =)= 则:a) 若栈中还有数据，则弹出。b) 若栈中无数据，则此时计算合法数据的长度，同时更新前后指针。具体怎么做，自己想吧，大概就是这个思路。时间复杂度o(n),空间复杂度o(n)
2. 使用dp。dp[i]表示以i点结尾的合法最长长度。那么更新规则为 若x为 =(= 则dp[x] = 0, 若 x为 =)= 且x-1为 =(= 则dp[x] = 2 + dp[x-2], 若x为 =)= 而x-1为 =)= 则判断x - dp[x-1] - 1的位置是什么，若其为 =(= 则与x匹配，那么结果为 dp[x] = dp[x-1] +2,否则dp[x] = 0
#+END_VERSE
* 0033
查找一个旋转的有序数组的目标值，如原有序数组[1,2,3,4],旋转有序数组[3,4,1,2],目标值4,要求时间复杂度为o(logn)。
解:
#+BEGIN_VERSE
二分查找，假设当前有left,right那么中间值为mid = (left+right)/2,那么结果应该在mid的左侧还是右侧呢？判断条件为下:
1. 如果left <= mid,且target in [left,mid],那么明显target在左区间,否则target<=right或者target >= mid,则在右区间。
2. 如果left >= mid(很明显此时right >= mid), 那么结果要么在mid右，要么在mid左，判断方式为，如果mid> right，那么在mid左，否则在mid右。
#+END_VERSE
* 0034
一个有序数组，其中数值是可以重复的，找出target出现的值的最左和最右的下标。要求时间复杂度o(logn)
解:
#+BEGIN_VERSE
1. 首先通过二分法来找到目标值，在找到后，分别找该位置左侧数组中最左的目标值，和该位置右侧数组中最右目标值。
#+END_VERSE
* 0037
0036是判断一个数独是否是合法的，即横竖即3*3都没有重复的数字，网上的基本都是暴力解，这种题，也归到中等难度，醉了。
0037是给定一个数独，要求填写其中的空白处。假设结果只有一组。
解:
#+BEGIN_VERSE
1. 暴力解，采用bfs或回溯+剪枝
2. 使用临时数组保存当前位置的横竖及3*3位置可填的数字，每次扫描一遍，如果某个位置只能填写一个数字，则填入，完长后重新扫描更新。或者也可以进行回溯+剪枝
#+END_VERSE
* 0040
0039和0040是一个类型的题，0039是给出一个数组，每个数可以使用多次，给一个target值，求可以加和成这个target值的所有情况。
0040是给一个数组，每个数只能使用一次，给一个target值，求可以加和成这个target值的所有情况。
#+BEGIN_VERSE
排序加dfs+剪枝,其实不难，重点是代码。
#+END_VERSE
* 0041
给一个自然数的数组，求其中没出现的最小的正整数。如[-1,7,8]返回0， [2,3,4]返回1.要求时间复杂度o(n),常数空间复杂度
解：
#+BEGIN_VERSE
该题要求常数空间复杂度，且时间复杂度o(n)，所以不能排序。其思路是将每个正整数放在其正确的位置，正确的位置的含义是，其数值与其位置的下标值保持一致(或者下标+1=其数值),如果没有正确的位置则不移动，如[-1,7,8],第一个数-1肯定没有正确的位置，所以不动，第二个7的正确位置应该是arr[7](或arr[6]),而数组长度不允许，所以也不动。最后从前往后遍历，遇到的第一个没有在正确位置的下标值(或下标+1)即为正确解。
#+END_VERSE
* 0042
给定一个数组，数组中的数表示一行木板中每个板的高度，求一场大雨过后，这些木板能装多少水。
解:
#+BEGIN_VERSE
1. 自己想的，利用两个前后指针，往前遍历，往前遍历的意思是，前指针往后，后指针往前。遍历到第一个可以装水的位置，如(1,1),计算这两个木板能装水的值，之后让最小木板的指针继续往前遍历，找到比这个木板大的位置，并计算这两个木板能够装水的量(需要减去之前已经计算过的水量)，以此类推。重点是每次都要让最小的木板往前，因为最大的木板不是屏jing.
#+END_VERSE
