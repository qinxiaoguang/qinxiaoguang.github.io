#+TITLE: leetcode题解
* 概述
过于简单的题，就不记录了
* 0002
题目大意
#+BEGIN_VERSE
计算两个链表的和，如1->2->3 + 2->4->6 = 3->6->9
#+END_VERSE

解决要点
#+BEGIN_VERSE
使用一个临时变量来保存其中的进位
#+END_VERSE

* 0003
题目大意
#+BEGIN_VERSE
字符串中的最长无重复子串，如abcbcaa ,最长无重复子串是 abc
#+END_VERSE

解决要点
#+BEGIN_VERSE
使用start,end两个指针来进行遍历，遍历的时候，只需要end依次往后移动，start不动，同时需要使用一个hashmap来记录当前最后一个出现的字母的位置，如abcb,遍利到c时，hashmap中的值是[a]=0,[b]=1,[c]=2,那么在每次遍利的时候，都要查询hashmap中是否存在当前字母，如果存在，则计算目前遍利的最长子串的长度，并将start放在当前位置，end继续往后遍历，同时更新hashmap中出现的重复的字母的位置。这样整个时间复杂度为o(n)。
#+END_VERSE
* 0004
题目大意
#+BEGIN_VERSE
有两个有序数组，求这两个有序数组的中位数，如果中位数有两个，则求这两个数的平均。如: [1,2], [3]的中位数是2, [1,2],[3,4]的中位数是 (2+3)/2 = 2,要求时间复杂度是log(m+n)
#+END_VERSE

解决要点
#+BEGIN_VERSE
题中要求时间复杂度是log(m+n)所以其一定是使用二分的方法进行解决，该题的主旨是求第k大的数，其中k=(m+n)/2,比较两个中位数的大小，假设第一个数组的中位数小于第二个数组的中位数，如果当前两个数组的总长度-第一个数组到中位数的长度 依然比k大，那么第k大的数就一定不在第一个数组的中位数左边的数中，所以可以将第一个数组中位数左边的数排除掉，依次类推。
#+END_VERSE

* 0005
求最大回文子串
解:
#+BEGIN_VERSE
1. 暴力,从每个串的中心往两边遍历。计算最大值。但是如果是偶数个数，就需要在每两个数之间填充一个字符。为了方便，无论是奇数还是偶数，都往其填字符,无论两个数之间还是两边，都填相同的字符，这样最终的字符串一定是奇数个，如 123 -> #1#2#3# ， 1234 -> #1#2#3#4#。时间复杂度O(n^2)
2. dp, 注意不要把其类比为两个字符串的最大公共子串，完全不相关！使用dp的方式为，若dp[i][j]为回文串，那么dp[i+1][j-1]也是回文, 所以有，~if s[i] == s[j] : dp[i][j] == (true && dp[i+1][j-1])~  时间复杂度O(n^2)
3. Manacher方法,与第一种方法类似，从中心点遍历，但是该方法的要点是利用到之前已经得到的回文串信息进行遍历，设rl[i]为当前点最大回文半径，回文半径就是以当前点为中心的回文长度的一半+1,那么这个问题就是求rl[i]的所有值，那么如何求rl[i]呢，假设当前遍历到了i点，并设mx为当前知道的所有回文串中最靠右的串(不是最大回文串)，而mid则是最靠右的回文串的中心点。那么如果i>=mx,则只能从中心往外扩展，而若i<mx,则可以使用到i关于mid的对称点(j)的信息，因为rl[j]的值已经求出，那么rl[i]>=r[j],如果i到mx的长度大于r[j]则，必然有r[i]=r[j],否则在r[j]的基础上继续向外边扩展。
#+END_VERSE
manacher方法参考:https://segmentfault.com/a/1190000003914228 、https://www.felix021.com/blog/read.php?2040
* 0006
求zigzag的水平方向字符串。
如:
#+BEGIN_VERSE
"abcdefghijklmn"的zigzag图如下
a    g    m
b  f h  l n
c e  i k  
d    j
那么他的水平方向字符串为: "agmbfhlnceikdj"
#+END_VERSE
解:
#+BEGIN_VERSE
其实把字符串的下标写出来:
1     7       13
2   6 8    12 14
3 5   9  11
4     10
是可以发现其中的规律的。
假设有n行，那么第i行的水平字符串的规律为: prefix+ 2*(n-i) 或 prefix + 2*(i-1),其实就是交替加上数值2*(n-i)和2*(i-1),但是要注意，如果n-i或者i-1为0，则跳过。
#+END_VERSE
* 0010
模仿正则的题，输入的正则匹配串只有a-z及 =*.= ，其中 =*= 表示匹配0到多个， =.= 匹配1个
解:
#+BEGIN_VERSE
1. 有向状态自动机，采用dfs或者bfs的方式或者递归进行解，但时间复杂度比较大。
2. 二维dp来解:dp[i][j]表示s[0,i)与p[0,j)是否match，那么dp[i][j]的更新规则则为:
- ~dp[i][j] = dp[i-1][j-1], if p[j-1]!= "*" && (s[i-1] == p[j-1] || p[j-1] == '.')~ 如果s[i],p[j]相等，或者p[j]是符号.，则dp[i+1][j+1]=dp[i-1][j-1]
- ~dp[i][j] = dp[i][j-2], if p[j-1] == "*" and pattern repeats for 0 times~ 如果当前p点是*符号，并且没有被匹配过，则dp[i+1][j+1]=dp[i+1][j-1]，因为*可以匹配0次。
- ~dp[i][j] = dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == "."), if p[j-1] == "*" and the pattern repeats for at least 1 times~ 如果当前点是*且被匹配1次以上，那么dp[i+1][j+1] = dp[i][j+1] && (s[i]==p[j-1] || p[j-1] = .)
其实大白话就分3种情况，当前点是字母，当前点是.,当前点是*等。
#+END_VERSE
* 0011
给定一个数组，数组中的每个点的数表示该点中线段的高，计算哪两个线段围成的矩形面积最大。数组中每相邻两个点的距离为1
解：
#+BEGIN_VERSE
使用i,j两个指针，分别指向数组首尾，并记录当前ij围成的面积是否最大，更新当前面积最大值，若arr[i]<arr[j]，则i右移即i++,否则j--.
该题巧妙在，i,j指针中的最小值是面积的极限，所有如果arr[i]<arr[j],移动j没有意义，即(i,j-1)不会比(i,j)大,所有只能移动i来更新面积大小。
#+END_VERSE

* 0014
题目是求多个串的最长公共前缀,如"abc","a","ab"的最长公共前缀是"a"
解:
#+BEGIN_VERSE
1. 暴力解，复杂度o(n^2)
2. 看起来此题很简单，但是实际还有更好的解法。先用一个最短的字符串做基准，让他依次与后边的所有串比较，被比较的串截取成与该最短串长度一样，并对比是否相等，若相等，则比较下一个，否则找出这两个串中的最长公共前缀串，方法是暴力，并用他更新当前的基准串。依次类推。该种方法的巧妙之处在于，不是一个字符一个字符的比较，而是多个字符一起比较。
#+END_VERSE
* 0015
找一个数组中所有的3个数加起来等于0的数
解:
#+BEGIN_VERSE
1. 暴力解o(n^3),超时
2. 先对数组排序，遍历该数组，遍历到i个数时，即求i后的数组中的两个数加起来等于arr[i]的负数。则题目变为求一个有序数组中加起来等于某数的两个数。解决其问题的思路是使用两个指针(i,j)，分别指向前后，如果两个指针的数加起来比目标值大，则j--, 否则i++,原因在于j--使得两个数减小，i++使得两个数变大。
#+END_VERSE
* 0020
求([{}])这些字符组成的字符串是否合法，合法的规则是每个括号都能正确匹配。
解:
#+BEGIN_VERSE
使用栈即可
#+END_VERSE
* 0022
给n对括号，生成不同的合法的括号组，如 =(())= 生成 =(())、()()、= 等
解:
#+BEGIN_VERSE
通过暴力搜索+剪枝的方法，每个点只有两个选择，要么加左括号，要么加右括号。其中加的时候必须有:
1. 左括号数目大于右括号
2. 当前还有剩余括号。
#+END_VERSE
* 0023
merge k个排序好的链表
解:
#+BEGIN_VERSE
1. 一个一个的依次merge
2. 使用小顶堆，将数据依次入队，并取出，O(mlogm),m是所有数据的长度
3. 使用小顶堆，不过每次入堆的数据是当前每个链表的头，入完一次后，取数据，取完后，将该数据的后边的数据再入堆，再取，依次类推。
4. 归并，分而治之，最后治理的是两个链表，就变成了merge两个链表的问题了。
#+END_VERSE
参考:https://liweiwei1419.github.io/leetcode-solution/leetcode-0023-merge-k-sorted-lists/
* 0025
给一个链表和k,每k个节点为一组进行反转，不足k的不反转，如 =1->2->3->4->5= ,在k=3时 =3->2->1->4->5=,其中0024是在k=2的时候的特例题，这里就汇总到一起。
解:
#+BEGIN_VERSE
使用两个指针，一个head一个tail,分别表示当前反转中的链表的head和tail,那么下一步就是将tail指向tail.next.next,而tail.next指向head,并同时将head更新为tail.next,并注意处理当前反转的长度是否到了k.
#+END_VERSE
* 0027
0026和0027基本是同一个类型的题，其中0026是将一个有序数组中的每个数都变为不重复的数，并返回其长度，而0027是将一个数组中的指定的值的数去掉，并返回其长度。但是两个题目中的要求都是，需要改变原有的数组结构，即删除就是真正删除。如[1,2,2,3]应该返回[1,2,3].
解:
#+BEGIN_VERSE
解决思路其实挺简单，就是使用两个变量，一个i,一个j,其中i表示当前遍历的点，j表示当前数组应填充的位置。依次往后遍历即可。
#+END_VERSE
* 0029
不使用乘法和除法实现除法。(非取余)
解:
#+BEGIN_VERSE
使用左移来操作，如x,y两个值，每次左移y，判断x是否比y大，如果大，则最终解必定比2^n大，如果小，则x=x-2^(n-1)，继续使用左移操作。
如代码:
#+END_VERSE

代码:
#+BEGIN_SRC go
func solve(x, y int) int {
    res := 0
    n := getMinN(x, y)
    for n >= 0 {
        res += int(math.Pow(float64(2), float64(n)))
        x -= (y << uint(n))
        n = getMinN(x, y)
    }
    return res
}

// 计算y * 2^n < x中N的最大值
func getMinN(x, y int) int {
    n := 0
    for x-y >= 0 {
        n += 1
        y <<= 1
    }
    return n - 1
}
#+END_SRC
* 0030
给定一个字符串s,并给一个长度相同的字符串数组，在 s 中找出可以恰好串联 words 中所有单词的子串的起始位置。
如s="barfoothefoobarman", arr=["foo","bar"],那么结果为[0,9],即s[0]的位置有barfoo,能够串联arr中的字符串，s[9]的位置是foobar,同样能串联。
解:
#+BEGIN_VERSE
刚开始考虑使用将arr中的字符串进行全排列后进行查找，但是这种方法复杂度过大，于是放弃。
在网上查找资料，发现了一个比较好的方案，使用滑动窗口来解决，需要注意的是，数组中的字符串，每个字符串的长度都想同,这是一个很重要的信息。解决方案如下：
假设数组中的每个单词长度为l。
将数组中的单词放入一个map<string,int>中，其中value是此单词出现的数量。
从s的开头依次往后遍历,遍历到l-1处。
从当前的遍历点开始，使用滑动窗口的思想进行查找。
以步长为l的方式往后查找，并使用两个指针，记录当前的滑动窗口，若当前步长宽度的单词在map中，则将此map中的对应的单词数量减1，若map中对应的该单词数量减1后的结果小于0，则以步长l向后移动滑动窗口的头指针，即将滑动窗口中的头部数据排出，同时更新map中的值，直到map中所有的单词数量>=0,若map中所有的单词对应的结果为0，则当前滑动窗口的值就串联了所有的arr中的单词。以此种方式一次往后查找，直到找到末尾。(细节处理就不说了，只说方法,总结来说，就是进行l次滑动窗口)
时间复杂度是o(l*(n/l)) = o(n)
#+END_VERSE
* 0031
给定一个排列的数字串，计算该串的下一个比当前更大的排列(即字母排序中的下一个排列)，如123->132, 231->312
解:
#+BEGIN_VERSE
该题是有规律的，规律是，从右往前遍历，找到第一个非升序的点，如123，第一个非升序的点就是2，那么将其后边比他大的最小点与他进行交换，交换完毕后，将此点后的所有数字重新排列(即从前到后升序排列即可)
如1354,先找到非升序的点是3，那么3后边比3大的最小点是4，将3和4交换位置，变为1453，同时将3原来的位置后边的数字，即53，进行重新排列，变为35，那么最终结果就是1435.
#+END_VERSE
* 0032
给出一个由 =()= 括号组成的字符串，计算其中的合法的字符串的最长长度。如 =(()= 为2， =()())= 为4.
解:
#+BEGIN_VERSE
1. 使用栈辅助以及两个指针(前后,来表示当前遍历的合法数据)，从头往后遍历，若为 =(= 则入栈，若为 =)= 则:a) 若栈中还有数据，则弹出。b) 若栈中无数据，则此时计算合法数据的长度，同时更新前后指针。具体怎么做，自己想吧，大概就是这个思路。时间复杂度o(n),空间复杂度o(n)
2. 使用dp。dp[i]表示以i点结尾的合法最长长度。那么更新规则为 若x为 =(= 则dp[x] = 0, 若 x为 =)= 且x-1为 =(= 则dp[x] = 2 + dp[x-2], 若x为 =)= 而x-1为 =)= 则判断x - dp[x-1] - 1的位置是什么，若其为 =(= 则与x匹配，那么结果为 dp[x] = dp[x-1] +2,否则dp[x] = 0
#+END_VERSE
* 0033
查找一个旋转的有序数组的目标值，如原有序数组[1,2,3,4],旋转有序数组[3,4,1,2],目标值4,要求时间复杂度为o(logn)。
解:
#+BEGIN_VERSE
二分查找，假设当前有left,right那么中间值为mid = (left+right)/2,那么结果应该在mid的左侧还是右侧呢？判断条件为下:
1. 如果left <= mid,且target in [left,mid],那么明显target在左区间,否则target<=right或者target >= mid,则在右区间。
2. 如果left >= mid(很明显此时right >= mid), 那么结果要么在mid右，要么在mid左，判断方式为，如果mid> right，那么在mid左，否则在mid右。
#+END_VERSE
* 0034
一个有序数组，其中数值是可以重复的，找出target出现的值的最左和最右的下标。要求时间复杂度o(logn)
解:
#+BEGIN_VERSE
1. 首先通过二分法来找到目标值，在找到后，分别找该位置左侧数组中最左的目标值，和该位置右侧数组中最右目标值。
#+END_VERSE
* 0037
0036是判断一个数独是否是合法的，即横竖即3*3都没有重复的数字，网上的基本都是暴力解，这种题，也归到中等难度，醉了。
0037是给定一个数独，要求填写其中的空白处。假设结果只有一组。
解:
#+BEGIN_VERSE
1. 暴力解，采用bfs或回溯+剪枝
2. 使用临时数组保存当前位置的横竖及3*3位置可填的数字，每次扫描一遍，如果某个位置只能填写一个数字，则填入，完长后重新扫描更新。或者也可以进行回溯+剪枝
#+END_VERSE
* 0040
0039和0040是一个类型的题，0039是给出一个数组，每个数可以使用多次，给一个target值，求可以加和成这个target值的所有情况。
0040是给一个数组，每个数只能使用一次，给一个target值，求可以加和成这个target值的所有情况。
#+BEGIN_VERSE
排序加dfs+剪枝,其实不难，重点是代码。
#+END_VERSE
* 0041
给一个自然数的数组，求其中没出现的最小的正整数。如[-1,7,8]返回0， [2,3,4]返回1.要求时间复杂度o(n),常数空间复杂度
解：
#+BEGIN_VERSE
该题要求常数空间复杂度，且时间复杂度o(n)，所以不能排序。其思路是将每个正整数放在其正确的位置，正确的位置的含义是，其数值与其位置的下标值保持一致(或者下标+1=其数值),如果没有正确的位置则不移动，如[-1,7,8],第一个数-1肯定没有正确的位置，所以不动，第二个7的正确位置应该是arr[7](或arr[6]),而数组长度不允许，所以也不动。最后从前往后遍历，遇到的第一个没有在正确位置的下标值(或下标+1)即为正确解。
#+END_VERSE
* 0042
给定一个数组，数组中的数表示一行木板中每个板的高度，求一场大雨过后，这些木板能装多少水。
解:
#+BEGIN_VERSE
1. 自己想的，利用两个前后指针，往前遍历，往前遍历的意思是，前指针往后，后指针往前。遍历到第一个可以装水的位置，如(1,1),计算这两个木板能装水的值，之后让最小木板的指针继续往前遍历，找到比这个木板大的位置，并计算这两个木板能够装水的量(需要减去之前已经计算过的水量)，以此类推。重点是每次都要让最小的木板往前，因为最大的木板不是屏jing.
2. 网上看的，先找到所有木板中的最高的那一个，然后针对该木板左边的一侧进行分析，以及右边的一侧进行分析(左右两侧其实就归为一类问题了)，此时最高木板已经确定，依次找到当前两侧遍历的最大木板，并计算其内容纳的值即可。
#+END_VERSE
* 0043
实现大数相乘。
#+BEGIN_VERSE
按照乘法的规则来实现就行，创建一个数组，该数组表示每个位(个位，十位)等当前的值，不需要进位，每次用一个数中的一个位与另外一个数依次相乘，并将结果保存在临时的数组中。最后在统一处理进位即可。其实这就是一个编程题，注意其中的细节就ok.也可以相应的做一些优化，如遍历到的数为0时直接跳过。
#+END_VERSE
* 0044
类似正则的完全匹配题，给出一串字符s和一个匹配项p，匹配项包含 =*= 和 =?=,其中 =*= 表示匹配任何字符0次或多次，而 =?= 可以和任何字符匹配一次，计算这两个字符串是否是完全匹配，注意 =*= 和 =?= 和前边的字符没任何练习。
如 =abc= 和 =*= 可以完全匹配。

解:
#+BEGIN_VERSE
1. 使用dp进行求解，主要的思想就是对*的处理，*是处理0次还是多次，dp[i][j]表示s[0,i)表示的字符串和p[0,j)的字符串是否完全匹配。那么当前p遍历点是*符号时，dp[i][j] = dp[i-1][j]||dp[i][j-1] 表示*号要么匹配0次，要么匹配1次。如当前ij点的分别的字符串为:abcd,a*,那么他们是否完全匹配是和abcd=~a||abc=~a*有关系。而若当前p点是?或者s[i]=p[j]，那么dp[i][j] = dp[i-1][j-1].
#+END_VERSE
* 0045
一个数组中，每个值表示他能跨越的步数，如给定[2,4,1,3],下标2表示能从当前位置最多走2步，到下标2的位置。给定一个数组，求其从头走到尾，用的最小步数，假设一定会走到结尾。如[2,3,1,2]的结果为2，步数下标为0->1->3
解:
#+BEGIN_VERSE
1. 通过贪心算法，设now_max为当前遍历点能达到的最远距离，times表示当前的最大步数。那么一个数组会被分为几个区间，如[2,3,1,4]，第一数字为2，那么下标0-2为第一个区间，从0下标可以通过1步来到达该区间的任何一点，此时当前的now_max为2，即当前区间能跨的最大距离为下标2，而times此时为1，表示只通过1步即可达到最大点。在该区间遍历，通过next_max=max(num[i]+i, next_max)来获取下一个now_max的最大值(即两步能到达的最远距离)，当遍历到now_max的点时，更新times+=1,且now_max=next_max.依次类推。
#+END_VERSE
* 0047
和46题一样是全排列的题，唯一的区别是，46题要求全部全排列，47题要求不重复。
解:
#+BEGIN_VERSE
1. 全排列的题的思路都是先固定第一个数，剩下的问题变成子问题。而固定第一个数的方式是进行交换。使用递归即可完成。如果要解决47题重复问题，则在交换的时候判断一下当前第一个数和要被交换的数是否相等，如果相等，则不交换即可解决重复问题。
#+END_VERSE
* 0048
将一个矩阵右旋转，要求直接对矩阵操作,不能创建新的矩阵空间。
解:
#+BEGIN_VERSE
1. 右旋可以看做先左右翻转后再左上/右下翻转
2. 很多旋转题都可以看做翻转，因为翻转操作比较简单。
3. 说到翻转，就延申到了两个数交换。两个数交换有几种解法，如交换ab
    a. 使用一个中间变量tmp: ~tmp=b; b=a; a=tmp~
    b. 使用一个数学方法: ~a=a+b; b=a-b; a=a-b~, 缺陷是可能有溢出问题。
    c. 使用异或，因为a^b^b=a: ~a=a^b; b=a^b; a=a^b~
#+END_VERSE
* 0049
给定定长的一组字符串，对这些字符串进行分组，要求两个字符串中字母相同(不要求位置相同)即为一组，如"abc","cba"就是同一组。
解:
#+BEGIN_VERSE
1. 利用排序(效率低)
2. 最好的方法，是利用原理：每个数都可以由一组唯一的质数相乘得到。将a-z的字母对应到不同的质数，如a对应2，b对应3，c对应5等等依次类推，如果两个字符串可为一组则其字符串中的字符对应的质数相乘则相等。如abc对应的质数相乘为2*3*5=30，而cba对应的质数相乘为5*3*2=30，相等即为同一组。
#+END_VERSE
* 0050
计算pow(x,n),其中x为符点数 (-100<x<100)，n为32位整数，可以为负数。
解:
#+BEGIN_VERSE
看到x^n次方，其肯定需要用大数，而x^n次方又可以用快速幂来解决，所以这个题牵扯到两个经典算法题，一个是符点数的大数运算，一个是快速幂。
大数运算就不说了，自己百度去。需要说下快速幂。(不知道为什么官方题解不用大数来算，直接用double来算，明显溢出了。。唉不懂)
快速幂其实并不是解决x^n次方的，而是去解决x^n%m。所以其实快速幂放这也算是一种拓展。快速幂的方法有两种，一种是使用递归，一种是使用迭代，迭代就是一个方法中使用循环来解决。
首先说下递归，可以将x^n次方写做 n如果是偶数时:(x^2)^n/2,n如果是奇数时:x*x^(n-1),利用这个原理，可以将pow(x,n)简化，如: pow(x,n)=if n is odd: return x*pow(x,n-1); else: return x*x * pow(x,n/2).
而迭代的方法则为，将n写成二进制，如x^13中的13写成二进制为1101,可以看到二进制中的第1、3、4位均为1，即13=2^0+2^2+2^3=1+4+8,所以x^13=x^(1+4+8)，所以有x^13=x^1*x^4*x8,可以看到括号中的值是随13中二进制中1的位数逐渐倍增的，所以代码就可以根据二进制中位数进行迭代，如(直接抄网上的):
ll binaryPow(ll a, ll b, ll m){
	ll ans = 1;
	while(b > 0){
		if(b & 1){
			ans = ans * a % m;
		}
		a = a * a % m;
		b >>= 1; 
	} 
	return ans;
#+END_VERSE
* 0052
51和52都是N皇后的问题。51是将所有的N皇后打印出来，而52则是求N皇后有多少种摆法。
解:
#+BEGIN_VERSE
此题无规律，只能通过DFS的方式进行深搜，搜索的同时，需要使用一些临时变量进行约束，使用三个数组，其中第一个数组为col，表示当前行已经被使用，无法放置皇后，left表示左斜对角已被使用，其中左斜对角的规律是，两坐标相减相等，右斜对角规律是两坐标相加相等。使用三个变量来查看等前位置是否可以放置，进行DFS回溯即可。
优化的地方就是不用数组来进行约束，而是使用位运算，某位为1就表示当前位不可放置。
#+END_VERSE
* 0053
最大连续子序列,求子序列的和的最大值。
解:
#+BEGIN_VERSE
如果当前和小于0，那么对当前的正确解是一个负面收益。所以用一个start表示当前的和的开头，end表示当前和的结束，当前和为sum，如果sum>0,则end继续往后遍历，如果sum < 0,则start=index+1,继续往后遍历，每次遍历都要把sum和临时的最大值ans比较一遍即可。本题是easy题，但很经典，所以拿来记录下。
#+END_VERSE
* 0054
顺时针(或改下题意，逆时针)螺旋打印矩阵。
而第59题是顺时针写入矩阵，和这题解法基本一样，不做答。
解:
#+BEGIN_VERSE
1. 直观 模拟求解
2. 层层输出，这个方案比较好，记录t_left,t_right,b_left,b_right分别为当前层的四个角的坐标，输出该层的数后每层递减，输出下层，一次递归即可。
#+END_VERSE
* 0055
跳跃游戏，给定一个数组，每个数表示最大跳跃的步数，求其是否能跳跃到最后一个位置上。这个题和前边的某题一样，不过前边那题是求跳到最后位置的最小步数。
解:
#+BEGIN_VERSE
1. 求最小步数的方式是使用分区的方法，每个区表示当前最小步数能跳的位置。而该题不需要分区即可解决。保存一个最远位置，该位置是当前所有步数中跳跃的最大距离。每次遍历的时候，查看当前位置是否小于最远位置，如果小于，则可以跳到当前位置，同时更新当前位置能跳跃的最大距离，和当前的最远距离比较并更新，依次类推即可。
#+END_VERSE
* 0056
重合区间合并问题：如 =[1,4],[2,5]= 合并为 =[1,5]= ,而 =[1,3],[3,5]= 也认为是重复的。那么给出一系列的数组，将可重复的数组合并，返回合并后的结果,如 =[1,4],[2,5],[7,8]= 返回 =[1,5],[7,8]=
57题和该题类似，不做解答。
解:
#+BEGIN_VERSE
按照每个区间的start进行排序，排序后从头往后建立连通图，所有连通图组成一个区间。或者可以通过暴力比较的方式。
#+END_VERSE
* 0060
第k个排列，1..n有n!种排列，求第k个排列，如n=3时，第1个排列是123，第2个排列是132.
解:
#+BEGIN_VERSE
1. 和46题一样，将所有的排列求出，打印第k个
2. 还有一个简单的方法就是固定第一个位置，计算该位置后的全排列有多少种，假设有q种，那么q<k时，结果就在这q种中，那么就变成了子问题，依次求解。如果q<k,那么第一个位置换下一个数后，k-=q,之后继续此过程。
#+END_VERSE
* 0061
旋转链表，就是查两次就行。
* 0062
从一个矩阵的左上角走到右下角有几种走法,只能向下或向右走。
解:
#+BEGIN_VERSE
1. 很多人想不到的题解，利用排列组合。从某个位置走到另一个位置，只能有两个方向，一个是下，一个是右，同时向下的步数一定是m,向右的是n，所有本题为从m+n中选择n步向右走的组合有几种，所以答案是C(m+n,n)
2. 使用dp的方式也可以解，答案就是dp[i,j]=dp[i-1,j]+dp[i,j-1],更新即可。第63题和该题类似，但是会在矩阵中放置障碍，障碍的地方不能走，这种题就只能使用dp求解，不能用排列组合求解。
#+END_VERSE
* 0064
给定一个矩阵，计算从左上角到右下角的路径和的最小值。
解:
#+BEGIN_VERSE
1. 使用dp求解，但是求解的思路有3种，分别是使用二维数组/一维数组/不使用等方式。其中思路基本都是一样，就是看你怎么去优化，dp的思路是dp[i][j]表示从(i,j)点到右下角的最小值，或者换个思路dp[i][j]表示从(0,0)到(i,j)的最小值，两个都是可以解的。
#+END_VERSE
* 0065
给定一个字符串，判断其是否是一个合法数字。如1e10是true,1ea是false等等.
解:
#+BEGIN_VERSE
1. 该题使用编译原理中使用到的有限状态自动机，即DFA，所以需要复习一下DFA、NFA的概念。其中DFA是Determinism Finite Automate,是确定有限状态自动机，而NFA则是Non-determinism Finite Automate，即非确定有限状态自动机。两者的区别是，DFA在输入任何一个字符后都能确定下一个状态是什么，而NFA则在输入一个字符后不确定下一个状态是什么，即下一个状态可以是当前状态，也可以是下一个状态，或者下下一个等等等的状态。对于每个NFA都能找到一个DFA与之等价。(NFA还存在一种情况就是不输入任何字符可以跳到其他的某种状态，由?等符号引起的),如正则表达式 ~a+ = aa*~ 和 ~a? = (a|ε)~ ,通过这些等式替换，可以将NFA转换为DFA。那么此题就是通过DFA来进行求解。如果能用正则那么用正则，如果不能用，就把正则转换为DFA，一般正则的实现方式就是将正则表达式转换为自动机来实现的。数字的正则可以尝试写出来为:  =\s*[\+-]?((\d+(\.\d*)?)|\.\d+)([eE][\+-]?\d+)?\s*=
#+END_VERSE
* 0069
经典简单题，求x的平方根.
解:
#+BEGIN_VERSE
1. 暴力法最蠢的方法就是从0循环到x/2，看看哪个是解。
2. 使用二分法
3. 最经典的算法，牛顿迭代法，https://www.zhihu.com/question/20690553 在这里可以看下什么是牛顿迭代法。一般迭代5~6次就逼近解，将最终值int化即可。但注意牛顿法有局限性，有些曲线并不收敛，可以看连接中的内容做了解。
#+END_VERSE
* 0070
爬楼梯，一次1步或两步，问有多少种爬法。
解:
#+BEGIN_VERSE
1. dp思路很容易得到这是一个斐波那契数列问题，即求解斐波那契。虽然简单，但是解法很多。第一种就是从前往后倒，第二种是利用矩阵快速幂，快速幂就不说了，主要是矩阵的公式，公式自己去上网搜一下吧。第三种是很多人都不知道的，就是斐波那契数列有一个公式，能计算第n个斐波那契值，也是上网搜。
#+END_VERSE
* 0071
给一个路径，求其绝对路径。如 =/./a/../b= 简化路径是以 =/= 开头。
解:
#+BEGIN_VERSE
1. 栈题，遇到 =..= 出栈，否则入栈即可。
#+END_VERSE
* 0072
给定两个字符串a,b，求a变成b需要几步，每次只能修改、删除、新增一个字符。
#+BEGIN_VERSE
1. 还是动规题，dp[i][j]表示a[0,i]->b[0,j]需要的最小步数，那么更新的规则为： 如果a[i]==b[j],则dp[i][j] = dp[i-1][j-1], 而a[i]!=b[j],则dp[i][j] = 1+ min(dp[i-1][j],dp[i][j-1], dp[i-1][j-1])
#+END_VERSE
* 0073
给定一个矩阵，如果A[i][j]为0，则将该i行j列都置为0，要求空间复杂度为O(1).
解:
#+BEGIN_VERSE
1. 从第2行第2列来遍历，若A[i][j]为0，则将该行的第一个元素标记为0，该列的第一个元素标记为0。即使用边界元素来标记，之后再循环一遍即可。但是第一列第一行公用同一个头部元素，所以需要额外搞一个值来标记。
#+END_VERSE
* 0074
给一个二维矩阵，矩阵中的每行数为递增，且Z型递增，即每行的开头都比上行的结尾大。给定一个目标值，求该矩阵是否存在该数。
解:
#+BEGIN_VERSE
1. 使用两次二分查找，首先查找该数可能位于哪一行。再对该行进行二分。
2. 使用一次二分查找，但其复杂度与第一种一样。即将二维矩阵看做一维数组来进行二分。
#+END_VERSE
* 0075
使用一次遍历的方式对数组排序，其中数组中只有0,1,2三个数。如[2,1,2,0,1] => [0,1,1,2,2].
解:
#+BEGIN_VERSE
使用三个指针，p0,p2,curr.其中p0表示当前数组中头部连续0的最右侧的位置，即下一个0应当放的位置，p2表示尾部连续的2最左侧的位置，即下一个2应该放置的位置。curr表示当前遍历的位置。若curr==0,则curr和p0交换位置，且p0++,同理出，curr==2，则curr和p2交换，且p2--.
#+END_VERSE
* 0076
给定两个字符串s,t求s中包含t的所有字母的最小子串。如 s:adobecodebanc ,t:abc,则答案为banc.
解:
#+BEGIN_VERSE
1. 非简化滑动窗口，一个left指针，一个right指针，将right指针向右扩张，直到left-right包含的字符串包含目标串，则left向右扩张，若依然符合条件，更新最小值，并left向右扩张，直到不符合条件，进行下一次的right向右扩张。
2. 简化滑动窗口，与第一个解法一样，不过是对字符串的优化，将s字符串所有不相关的字符去除，如abdc简化为(a,0),(b,1),(c,3)，再对简化后的数据做滑动窗口。
#+END_VERSE
* 0077
给出n和k,求0..n中所有只有k个数的子集。如n=4,即求[0,1,2,3]中，[0,1][0,2][0,3][1,2][1,3][2,3]等子集。
解:
#+BEGIN_VERSE
1.明显还是回溯的方法，方式就是，先固定第一个数，对后边的数进行k-1的回溯。依此类推。
2. 还有一种方法没看懂，但是是用的二进制的方法。
#+END_VERSE
* 0078
给定一个没重复数的数组，求该数组所有的子集，包含空集。
解:
#+BEGIN_VERSE
1. 同样使用回溯法。先固定第一个数，求该数后边所有数的子集。每固定一个数，都将当前解放在结果里。
2. 最好的方法，使用二进制的方法求解，如0000就表示空集，0001就表示选第一个数，依此类推。
#+END_VERSE

* 0079
单词搜索，给定一个矩阵，矩阵中的数据是字符，给定一个字符串，求是否能在该矩阵中搜索到。每个字符只能使用一次，搜索时只能搜相邻的数据。
解: dfs即可。

* 0080
给定一个数组，数组中是排序后的有重复数的数值，要求原地删除数组，保证每个数最多只出现两次。
解:
#+BEGIN_SRC rust
// 原地删即使用双指针，一个快指针，一个慢指针，快指针遍历数组，慢指针记录需要被覆盖的位置。
// 直接看代码吧。
let i = 0;
for n in nums.iter(){
    if i<2 || n!= nums[i-2]{
        nums[i] = n;
        i+=1;
    }
}
#+END_SRC
* 0084
计算给定的柱壮图，组成的矩形的最大面积。
解
#+BEGIN_VERSE
1. 核心思想是 以某个柱壮为中心点，找到两边第一个小于该柱壮的位置，计算包含此柱壮的最大矩形
2. O(n)的计算方法是，通过栈来保存一个上升的序列,保存的是数组的下标,栈内初始值为-1，当前遍历点如果小于栈顶元素，则弹出，此时栈顶元素必定是第一个小于弹出元素的值，此时计算包含弹出元素的最大矩形的面积，计算公式为height*(i-top-1),其中height是弹出的矩形的高，i是当前遍历到的位置，top是弹出后当前栈顶的小标。依次类推。
#+END_VERSE
