#+TITLE: leetcode题解
* 概述
过于简单的题，就不记录了
* 0002
题目大意
#+BEGIN_VERSE
计算两个链表的和，如1->2->3 + 2->4->6 = 3->6->9
#+END_VERSE

解决要点
#+BEGIN_VERSE
使用一个临时变量来保存其中的进位
#+END_VERSE

* 0003
题目大意
#+BEGIN_VERSE
字符串中的最长无重复子串，如abcbcaa ,最长无重复子串是 abc
#+END_VERSE

解决要点
#+BEGIN_VERSE
使用start,end两个指针来进行遍历，遍历的时候，只需要end依次往后移动，start不动，同时需要使用一个hashmap来记录当前最后一个出现的字母的位置，如abcb,遍利到c时，hashmap中的值是[a]=0,[b]=1,[c]=2,那么在每次遍利的时候，都要查询hashmap中是否存在当前字母，如果存在，则计算目前遍利的最长子串的长度，并将start放在当前位置，end继续往后遍历，同时更新hashmap中出现的重复的字母的位置。这样整个时间复杂度为o(n)。
#+END_VERSE
* 0004
题目大意
#+BEGIN_VERSE
有两个有序数组，求这两个有序数组的中位数，如果中位数有两个，则求这两个数的平均。如: [1,2], [3]的中位数是2, [1,2],[3,4]的中位数是 (2+3)/2 = 2,要求时间复杂度是log(m+n)
#+END_VERSE

解决要点
#+BEGIN_VERSE
题中要求时间复杂度是log(m+n)所以其一定是使用二分的方法进行解决，该题的主旨是求第k大的数，其中k=(m+n)/2,比较两个中位数的大小，假设第一个数组的中位数小于第二个数组的中位数，如果当前两个数组的总长度-第一个数组到中位数的长度 依然比k大，那么第k大的数就一定不在第一个数组的中位数左边的数中，所以可以将第一个数组中位数左边的数排除掉，依次类推。
#+END_VERSE

* 0005
求最大回文子串
解:
#+BEGIN_VERSE
1. 暴力,从每个串的中心往两边遍历。计算最大值。但是如果是偶数个数，就需要在每两个数之间填充一个字符。为了方便，无论是奇数还是偶数，都往其填字符,无论两个数之间还是两边，都填相同的字符，这样最终的字符串一定是奇数个，如 123 -> #1#2#3# ， 1234 -> #1#2#3#4#。时间复杂度O(n^2)
2. dp, 注意不要把其类比为两个字符串的最大公共子串，完全不相关！使用dp的方式为，若dp[i][j]为回文串，那么dp[i+1][j-1]也是回文, 所以有，~if s[i] == s[j] : dp[i][j] == (true && dp[i+1][j-1])~  时间复杂度O(n^2)
3. Manacher方法,与第一种方法类似，从中心点遍历，但是该方法的要点是利用到之前已经得到的回文串信息进行遍历，设rl[i]为当前点最大回文半径，回文半径就是以当前点为中心的回文长度的一半+1,那么这个问题就是求rl[i]的所有值，那么如何求rl[i]呢，假设当前遍历到了i点，并设mx为当前知道的所有回文串中最靠右的串(不是最大回文串)，而mid则是最靠右的回文串的中心点。那么如果i>=mx,则只能从中心往外扩展，而若i<mx,则可以使用到i关于mid的对称点(j)的信息，因为rl[j]的值已经求出，那么rl[i]>=r[j],如果i到mx的长度大于r[j]则，必然有r[i]=r[j],否则在r[j]的基础上继续向外边扩展。
#+END_VERSE
manacher方法参考:https://segmentfault.com/a/1190000003914228 、https://www.felix021.com/blog/read.php?2040
* 0006
求zigzag的水平方向字符串。
如:
#+BEGIN_VERSE
"abcdefghijklmn"的zigzag图如下
a    g    m
b  f h  l n
c e  i k  
d    j
那么他的水平方向字符串为: "agmbfhlnceikdj"
#+END_VERSE
解:
#+BEGIN_VERSE
其实把字符串的下标写出来:
1     7       13
2   6 8    12 14
3 5   9  11
4     10
是可以发现其中的规律的。
假设有n行，那么第i行的水平字符串的规律为: prefix+ 2*(n-i) 或 prefix + 2*(i-1),其实就是交替加上数值2*(n-i)和2*(i-1),但是要注意，如果n-i或者i-1为0，则跳过。
#+END_VERSE
* 0010
模仿正则的题，输入的正则匹配串只有a-z及 =*.= ，其中 =*= 表示匹配0到多个， =.= 匹配1个
解:
#+BEGIN_VERSE
1. 有向状态自动机，采用dfs或者bfs的方式或者递归进行解，但时间复杂度比较大。
2. 二维dp来解:dp[i][j]表示s[0,i)与p[0,j)是否match，那么dp[i][j]的更新规则则为:
- ~dp[i][j] = dp[i-1][j-1], if p[j-1]!= "*" && (s[i-1] == p[j-1] || p[j-1] == '.')~ 如果s[i],p[j]相等，或者p[j]是符号.，则dp[i+1][j+1]=dp[i-1][j-1]
- ~dp[i][j] = dp[i][j-2], if p[j-1] == "*" and pattern repeats for 0 times~ 如果当前p点是*符号，并且没有被匹配过，则dp[i+1][j+1]=dp[i+1][j-1]，因为*可以匹配0次。
- ~dp[i][j] = dp[i-1][j] && (s[i-1] == p[j-2] || p[j-2] == "."), if p[j-1] == "*" and the pattern repeats for at least 1 times~ 如果当前点是*且被匹配1次以上，那么dp[i+1][j+1] = dp[i][j+1] && (s[i]==p[j-1] || p[j-1] = .)
其实大白话就分3种情况，当前点是字母，当前点是.,当前点是*等。
#+END_VERSE
* 0011
给定一个数组，数组中的每个点的数表示该点中线段的高，计算哪两个线段围成的矩形面积最大。数组中每相邻两个点的距离为1
解：
#+BEGIN_VERSE
使用i,j两个指针，分别指向数组首尾，并记录当前ij围成的面积是否最大，更新当前面积最大值，若arr[i]<arr[j]，则i右移即i++,否则j--.
该题巧妙在，i,j指针中的最小值是面积的极限，所有如果arr[i]<arr[j],移动j没有意义，即(i,j-1)不会比(i,j)大,所有只能移动i来更新面积大小。
#+END_VERSE

* 0014
题目是求多个串的最长公共前缀,如"abc","a","ab"的最长公共前缀是"a"
解:
#+BEGIN_VERSE
1. 暴力解，复杂度o(n^2)
2. 看起来此题很简单，但是实际还有更好的解法。先用一个最短的字符串做基准，让他依次与后边的所有串比较，被比较的串截取成与该最短串长度一样，并对比是否相等，若相等，则比较下一个，否则找出这两个串中的最长公共前缀串，方法是暴力，并用他更新当前的基准串。依次类推。该种方法的巧妙之处在于，不是一个字符一个字符的比较，而是多个字符一起比较。
#+END_VERSE
* 0015
找一个数组中所有的3个数加起来等于0的数
解:
#+BEGIN_VERSE
1. 暴力解o(n^3),超时
2. 先对数组排序，遍历该数组，遍历到i个数时，即求i后的数组中的两个数加起来等于arr[i]的负数。则题目变为求一个有序数组中加起来等于某数的两个数。解决其问题的思路是使用两个指针(i,j)，分别指向前后，如果两个指针的数加起来比目标值大，则j--, 否则i++,原因在于j--使得两个数减小，i++使得两个数变大。
#+END_VERSE
