#+TITLE: unix读书笔记

* 概述
unix的四本书:
- unix编程实战
- unix编程艺术
- unix环境高级编程
- unix网络编程

 以下笔记都是瞎记。

* 笔记
1. 内核是操作系统的占用的空间。用户空间是应用程序的空间
2. 程序要访问设备，必须要经过内核。只有内核才能直接管理设备。
3. 内核提供访问设备的api。而编程库则对这些api进行了封装。即库函数并不是内核提供的。
4. 在一些命令中敲Ctrl+z，程序会到后台运行，之后执行fg，则会切换回来。
5. 使用 =man -k= 来正则搜索相关指令，如 =man -k utmp= 会搜索*utmp*的相关指令。
6. 大部分头文件都在 =/usr/include=
7. read,close,open等系统调用可以读取系统中的一些文件，open用来打开一个文件并返回文件描述符，read来读取文件描述符中对应的文件。
8. 缓冲区是与系统调用有关的，如果缓冲区大，则系统调用小(如调用read，read是系统调用，其可以传缓冲大小，如果缓冲小，则read次数增多)，而缓冲区小，则系统调用大，开销大。系统调用会把系统才用户态转换到内核态并同时执行该函数，而切换到内核态后，cpu等环境也要相应的做切换(切换到超级用户或管理员模式)并执行相应的调用及代码，而在执行完毕后，需要把现场恢复，其过程耗费时间是比较长的。cpu中是有相应的标记来记录当前的模式(管理员模式还是用户模式)。所以要明白，系统调用的开销是很昂贵的。如一个例子：缓冲大小为1时，执行时间50s,缓冲大小为16384时，执行时间为0.18s.
9. 应用程序可以设置缓冲，那么内核同样也可以有缓冲区。用户在读取一块数据的时候，会进行系统调用，及在内核进行读取数据，内核在读取数据的时候，一般不会直接从磁盘进行读取，而是在内存中的一个缓冲处进行读取，所以读取文件的流程一般是先将文件缓存到内核内存中，再进行读取。但是read和write其实与磁盘并无多大交互，read只是将内核缓存拷贝到进程缓存中，内核缓存无数据时，其会把当前进程挂起，一段时间(很短)后内核把相应的数据拷贝到内核缓冲中，然后再把数据拷贝到进程缓冲中。而write是把进程缓冲数据拷贝到内核缓冲中。理论上内核可以在任何时刻写入磁盘，但并不是write引起写的动作，而是在内核缓冲区积累到一定的量后才进行写入。
10. unix每次在打开一个文件的时候都有一个指针记录当前的位置，而在读取的时候，指针会进行移动，那么移动后想要回到某位置呢，需要使用lseek命令。该指针是与文件描述符所关联的，而不是与文件关联。如果两个程序打开同一文件会有两个文件描述符，也就是有两个位置指针。
11. 在ll中显示的目录的空间通常都是相同的，因为空间都是以块为单位分配的
12. 二进制把不需要的位置设为0，这种技术就是掩码
13. 有些命令在执行的时候会被赋予root权限，如passwd，该命令会修改/etc/passwd文件，但是/etc/passwd文件只能有root来修改，那么当使用passwd时会被赋予root权限来修改登录者的密码。这种属性叫文件特殊属性(或特殊权限)。文件特殊属性一般有三种:SUID(set-user-UD),set-group-ID,sticky位等。而ll显示的方法是，用户属性的x被替换为s时，就表示其有SUID的属性，group的x被替换为s,other的x被替换为t.SUID表示，命令被其他用户执行的时候，会被赋予命令所有者的权限，如passwd命令的所有者是root,如果被设置了SUID位，那么其他用户在执行该命令的时候，该命令会有root的权限。而SGID则是执行命令的人拥有了该命令所属组的权限。或者按照书中的说法来说，SUID位告诉内核，运行这个程序的时候认为是由这个文件所有者在运行这个程序。sticky位作用在文件程序上，表示即使没有人在使用该程序，也要把他放在交换空间中。而sticky作用在目录上，则表示，该目录里的文件只能由创建者来删除，如/tmp目录。
14. 一个文件的权限通过9位表示，其中前3位是文件所有者的权限，而不是当前登录用户的权限。
15. 在创建文件的时候，需要填入文件的9位权限，即rwxrwxrwx的这些权限，但是传入的权限，并不是文件生成后最终的权限，最终的权限需要经过系统里的掩码处理，这个掩码就是系统里的umask，一般为022,022表示删除group和other的w权限，即在创建文件的时候即使用户想要group和other有对文件的写权限，但经过umask掩码创建完毕后，group和other都不会有写权限。
16. 文件通常包含3个时间，创建时间，最后访问时间，最后修改时间，通过touch命令，可以修改文件的最后访问时间和最后修改时间。
17. 文件系统分为3个区，分别是超级块、i-节点表、数据区。超级块存储文件系统本身的信息，如每个区域的大小。i-节表中的inode记录文件的一些属性如文件大小，文件所有者，最后访问时间等，每个i节点的大小相等，而i-节点表实际上就是一个列表,如inode0就是列表中的第一个数据，文件系统中每个文件都拥有一个inode.数据区里存放文件的内容，数据区里每个块大小都一样，如果一个文件超过一个块的大小，就会分配到其他块里。
18. inode节点存放了文件内容存放的块位置。创建文件后，会将文件的inode和文件名存放在文件目录系统中。文件目录是一个包含了文件名字列表的特殊文件，包含inode和文件名的表。多重连接的inode是相同的，指向同一个文件， =.= 的i节点就是pwd目录的i节点。
19. cat的工作流程是首先找到文件的inode,在inode表中找到其中的块位置，并进行读取。
20. 一个大文件在存储的时候，i节点中记录的数据块数可能过大，存储不了，而此时i节点存储块位置的方式就是前n个存储常规的块位置信息，剩下的数据块则存放在一个单独的数据块中，并用i节点关联。
21. link的inode是相同的。而link -s的inode是不同的，但是都是像操作同一个文件。
22. 装载是将一个磁盘装载到文件系统的某个目录上，比如/目录装载了磁盘1，而/home则装载了磁盘2，那么从/到/home则进入了不同的文件系统。 不同的文件系统不同的文件可能有相同的inode节点值。
23. 在unix系统中，每个设备都被当作是一个文件，每个设备都有一个文件名，一个inode,一个文件所有者，一个权限位的集合以及修改时间。与文件相关的属性，也被应用到终端以及其他设备(如/dev/mouse*是鼠标，/dev/dsp*是声卡文件)。一个键盘，一个打印机都可以被认为是终端，一个telnet或ssh的窗口也被认为是终端。
24. 存放设备的文件存放在目录/dev中，但是可以在任何目录中创建设备文件
25. 可以通过系统调用(open,read)等来读取设备中的数据。终端支持read和write,但不支持lseek。
26. 使用tty来显示当前终端的文件，如ssh登录到一台设备后，使用tty显示 =/dev/pts/2= 那么使用 =echo haha > /dev/pts/2= 就会将haha显示到当前的终端窗口上。同理，你可以使用root权限，来像 =/dev/pts/2= 的终端窗口来发送数据。
27. 设备文件的inode节点存储的是指向内核子程序的指针，而不是文件大小和存储列表。内核中传输设备数据的子程序被称为设备驱动。
28. 设备文件的权限写，表示是否有权限向设备中发送数据，而权限读是从设备中读取数据。
29. 目录中存放的是i节点和文件名，i节点中有一个变量来标识i节点的类型,如文件类型，还是设备类型等等。
30. 磁盘文件和设备文件有相似之处，也有不同之处，两者都有一些特有的属性。
31. 文件描述符有很多模式，如O_APPEND,O_SYNC等。可以通过fcntl来给文件描述符来设置相应的模式
32. 终端对应的文件描述符也有很多设置，比如stty就是显示终端的文件描述符对应的设置，可以使用 =stty --all= 显示所有设置。如eof=^D，就表示Ctrl+D 输入了eof。其中一些命令前有减号，表示关闭相应的设置，如 =-olcuc= 表示输出时将小写转换为大写被禁止。可以使用stty来修改相应的设置，如 =stty erase X= 表示使用X键来表示删除.有时候经常会不小心按到 =ctrl+s= 就会出现终端卡死的现象，可以将其命令修改成其他的，如 =stty stop ^P= 这样只有 =ctrl+p= 才会使终端stop.抽空可以详细了解下，里面很多有趣的东东。
33. 终端的缓冲区其实就是输入字符的时候，如果没遇到回车，不会将这些字符发送给程序。这些字符其实就是保存在了缓冲区中。
34. 在用shell并发的时候，会用到文件描述符，如&128,就是128对应的文件描述符，默认情况下使用read方法来读取文件描述符中的内容的时候，会进行阻塞，所以可以通过这个特性，来实现n个程序并发的功能。但是也可以通过文件描述符的相关属性，来关闭这种阻塞(O_NDELAY),这样在读取的时候，如果没有内容则直接返回0.
35. 信号是内核产生的，信号可以被程序忽略和捕捉，但是有两种信号是不能被程序忽略和捕捉,这样可以达到程序可以通过其他方式强制退出，防止其一直运行。
36. 程序计时器有3种，一种是真实时间(所有时间)，一种是用户态时间(虚拟)，一种是用户态加内核态时间(实用)
37. 程序在处理多信号的时候有多种选择，不同的系统处理多信号的情况不大相同，遇到新的信号可能会阻塞，也可能是直接处理该信号，处理完后再回到原信号(递归)。一般递归的处理信号要求函数是可重入的(递归调用不会出现错误)。处理信号的时候可以忽略，也可以调用相关函数来执行等等。POSIX接口就是使用广泛的信号处理模型，其兼容了老版本的信号处理模型，并能设置一些相关设置，如哪些信号是可以阻塞的等等。
38. 一段修改一个数据结构的代码如果在运行时被打断将导致数据的不完整或损毁，则称这段代码为临界区。程序在处理信号的时候，必须决定哪段代码为临界区，然后设法保护这段代码。保护临界区最简单的办法就是阻塞或者忽略那些处理函数将要使用或修改特定数据的信号。
39. 有些进程与一个终端想连，使用ps的时候第二列就是显示的对应终端。如果没有选项，ps就是列吃当前终端运行的程序，而ps -a则列出所有终端运行的程序。-l打印更多的细节，其中S列是程序的状态，值为R为运行，S是sleep睡眠，UID为进程的所属用户的id,pid是该进程的id,ppid是该进程的父进程的id,PRI是进程的优先级，SZ是进程的内存大小等。-f选项可以让ps输出格式化，便于阅读。
40. 进程和文件的保存相似，进程也有一个内存页面，来保存其进程分配到内存的位置。
41. shell在执行程序的时候会创建一个新的进程执行，并等待这个进程执行结束。方法就是通过fork(创建一个新的进程)、execvp(用来运行相关程序，如ls)、以及父进程(shell)等待子进程(要运行的程序)(通过wait/exit来实现)
42. 在使用execvp来创建进程并执行相关的shell命令的时候，会将原进程的命令清除，并用新的进程指令代替，所以原进程后续的输出均不会被打印。
43. shell中的if语句后边可以跟命令，如果命令执行成功且有结果，返回值是0，如果执行失败则返回值非0.如grep some tmp.txt找存在some的行，如果没找到，返回的是1，即不成功，可以利用这些特性，和if进行组合操作.如果if后有一系列的命令，那么最后一个命令才会被当做条件判断。
44. set命令是列出当前shell定义的所有变量。shell是一个进程，使用export导出一个变量的时候，该进程及其子进程都可以使用到该变量，或者说该登录的该shell一直可以使用到该变量。而不使用export导出时，其实就是正常的变量赋值,该变量就是局部变量。或者说export就是把一个局部变量添加到该进程环境中。
45. 三个标准输入输出文件描述符都是特殊的文件描述符.大步分unix程序都是从文件或标准输入读取数据，若给了文件名，则从文件中读数据，若没给，则从标准输入读数据，所以你可以测试一下cat命令，不给文件，那么就会读取标准输入。
46. 使用>来重定向，其实是对shell进行的，当你执行cat file > file2时，shell将输出重定向到文件file2中。而程序并不关心你的输出放在哪。重定向是你的shell做的事。
47. 三个基本的重定向操作：1. who>userlist,将stdout连接到一个文件 2. sort < date, 将stdin连接到一个文件。3. who | sort 将stdout和stdin连接。
48. 每个进程都保存一个文件描述符的数组，其中一般012都被分配给了终端的stdin,stdout,sdterr的连接,再次分配时，都会先分配当前数组中可用的最小位置。
49. 将stdin连接到文件有以下几种方法。1. close-then-open,即先关闭文件描述符0,再打开文件，因为分配最低位置，所以会将0描述符分配给该文件。2.open-close-dup-close,先打开文件，分配一个描述符，再关闭0,再复制一份，此时复制的分配了0 ，再把之前的关闭。
50. 进程创建一个管道，会使用两个文件描述符.但一般都是通过fork和pipe来共用，使用pipe创建一个管道，使用fork来复制进程环境，同时复制pipe创建的管道，此时子进程和父进程可以共享该管道，一个读一个写。
51. 管道并非文件。linux中的管道与golang中channel是很相似的。
52. unix提供接口来处理来自不同数据源的数据：磁盘文件/设备文件(open,read,write)、管道(pipe创建,fork共享,read,write)、sockets(socket,listen,connect,read, write).
53. 可以使用fdopen来打开一个fd文件,传入的是fd的id,而popen是打开一个shell指令，并使用文件的方式与该shell指令相连。如FILE* fp = popen("ls","w"); 即popen与进程连接，可以与进程的输入输出进行交互。
54. 管道在一个进程中进行创建，通过fork在两个进程间进行共享，即管道只能连接在同一台机器上的相关进程。Socket则是另外一种进程间通信的方式，其可以在不同种类的进程中创建类似管道的连接，且可以连接两个不同机器间的进程。
55. telnet就像一部电话，与远程主机的某个端口进行相连，并把键盘的输入通过连接发送过去，将输出展示在屏幕上。
56. 文件/etc/services中定义了众所周知服务端口号的列表。
57. socket创建一个通信端点并返回一个标识符，这个标识符可以在/proc/${pid}/fd文件中找到。之后使用bind来将相关的地址和端口号绑定到对应的sockek上。listen请求内核允许指定的socket接收呼叫，并不是所有的socket都能接收呼叫,并指定允许接入连接的数目，接入的连接会放到相应的队列中去。使用accept来接收调用，他会阻塞当前进程，在接受到请求后会返回一个文件描述符，并用该文件描述符进行读写操作。而connect则是客户端的一个操作，其连接到远程服务器，并返回一个fd，并通过该fd进行读写操作。
58. 基于socket的客户/服务器系统大多是类似的，虽然电子邮件、文件传输、远程登录和分布式数据库以及其他的internet服务在屏幕显示的内容相异，但他们的运作原理是一致的。
59. 一般的服务器运行有两种方式，一种是通过socket的队列来限制连接数，来请求后不创建新的进程，而是自己去实现相关逻辑。另外一种方式是通过代理的方式，来请求后创建一个进程(fork,exec)来调用相关逻辑，代理的方式会多次进行系统调用。
60. 说到代理，就想到了反向代理和正向代理的关系，这里插几句，正向代理是代理的客户端，如vpn，客户端无法进行fq,但是可以通过代理进行，这是正向代理，而反向代理则是代理的服务器，如nginx.
61. 常规管道(pipe创建)由进程创建的单向数据流，并由最后一个进程关闭。而命名管道则可以连接两个不相关的进程，并且可以独立于进程存在，这种命名管道被称为FIFO(由mkfifo创建),命名管道是一个队列而不是常规文件。其类似golang中的channel.
62. 共享内存是进程间通信的一个手段，两个进程维护指针指向同一个内存段，并可以有权限的进行访问。并不是在golang定义个全局变量就是共享内存，需要通过相关的函数来创建或者查找共享内存段。
63. 信号量是一个内核变量，它可以被系统中的任何进程所访问，信号两是系统级的全局变量。使用semget来创建信号量。
64. 命名socket又称Unix域Socket,它使用文件名做为地址而不是主机和端口号，它们仅仅可以连接到一个机器上的进程。有面向消息和面向流两个版本。面向消息的如信号(kill-signal)。
65. IPC(进程间通信的方式)
    - environ: 系统环境变量，在使用fork时，子进程可以将父进程的环境变量复制，但不能改变父进程的环境变量，所以可以用于父进程传递给子进程
    - pipe: 管道，单向数据流，面向流的
    - kill - signal: 信号，通过kill发送，非信号量
    - 网络socket: 连接两个不同主机的进程，创建的时候需要指定主机名和端口号。通过相关的socket来进行通信。可以面向流和消息，双向通信。
    - Unix域socket： 创建的时候指定文件名，连接同一主机的两个无关进程，支持面向流和消息，双向传输。
    - 命名管道(Named pipes):通过mkfifo来创建的，可以连接两个无关的进程，命名管道由文件名来标志，通过read/write来传输数据，只能单向传输数据，面向流的。
    - File locks: 进程可以对文件的某段进行加锁，利用锁的机制可以实现进程间的通信。
    - 共享内存:进程可以通过shmget和shmat来创建可以被多个进程共享的内存段，这是IPC最为有效的办法，因为所有的通信并不需要数据的传输。
    - 信号量：系统级的变量，进程可以对信号量做增1减1等的操作，或者等待信号量到达某个特定的值。
    - 消息队列。
    - 文件。
