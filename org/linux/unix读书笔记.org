#+TITLE: unix读书笔记

* 概述
unix的四本书:
- unix编程实战
- unix编程艺术
- unix环境高级编程
- unix网络编程

 以下笔记都是瞎记。

* 笔记
1. 内核是操作系统的占用的空间。用户空间是应用程序的空间
2. 程序要访问设备，必须要经过内核。只有内核才能直接管理设备。
3. 内核提供访问设备的api。而编程库则对这些api进行了封装。即库函数并不是内核提供的。
4. 在一些命令中敲Ctrl+z，程序会到后台运行，之后执行fg，则会切换回来。
5. 使用 =man -k= 来正则搜索相关指令，如 =man -k utmp= 会搜索*utmp*的相关指令。
6. 大部分头文件都在 =/usr/include=
7. read,close,open等系统调用可以读取系统中的一些文件，open用来打开一个文件并返回文件描述符，read来读取文件描述符中对应的文件。
8. 缓冲区是与系统调用有关的，如果缓冲区大，则系统调用小(如调用read，read是系统调用，其可以传缓冲大小，如果缓冲小，则read次数增多)，而缓冲区小，则系统调用大，开销大。系统调用会把系统才用户态转换到内核态并同时执行该函数，而切换到内核态后，cpu等环境也要相应的做切换(切换到超级用户或管理员模式)并执行相应的调用及代码，而在执行完毕后，需要把现场恢复，其过程耗费时间是比较长的。cpu中是有相应的标记来记录当前的模式(管理员模式还是用户模式)。所以要明白，系统调用的开销是很昂贵的。如一个例子：缓冲大小为1时，执行时间50s,缓冲大小为16384时，执行时间为0.18s.
9. 应用程序可以设置缓冲，那么内核同样也可以有缓冲区。用户在读取一块数据的时候，会进行系统调用，及在内核进行读取数据，内核在读取数据的时候，一般不会直接从磁盘进行读取，而是在内存中的一个缓冲处进行读取，所以读取文件的流程一般是先将文件缓存到内核内存中，再进行读取。但是read和write其实与磁盘并无多大交互，read只是将内核缓存拷贝到进程缓存中，内核缓存无数据时，其会把当前进程挂起，一段时间(很短)后内核把相应的数据拷贝到内核缓冲中，然后再把数据拷贝到进程缓冲中。而write是把进程缓冲数据拷贝到内核缓冲中。理论上内核可以在任何时刻写入磁盘，但并不是write引起写的动作，而是在内核缓冲区积累到一定的量后才进行写入。
10. unix每次在打开一个文件的时候都有一个指针记录当前的位置，而在读取的时候，指针会进行移动，那么移动后想要回到某位置呢，需要使用lseek命令。该指针是与文件描述符所关联的，而不是与文件关联。如果两个程序打开同一文件会有两个文件描述符，也就是有两个位置指针。
11. 在ll中显示的目录的空间通常都是相同的，因为空间都是以块为单位分配的
12. 二进制把不需要的位置设为0，这种技术就是掩码
13. 有些命令在执行的时候会被赋予root权限，如passwd，该命令会修改/etc/passwd文件，但是/etc/passwd文件只能有root来修改，那么当使用passwd时会被赋予root权限来修改登录者的密码。这种属性叫文件特殊属性(或特殊权限)。文件特殊属性一般有三种:SUID(set-user-UD),set-group-ID,sticky位等。而ll显示的方法是，用户属性的x被替换为s时，就表示其有SUID的属性，group的x被替换为s,other的x被替换为t.SUID表示，命令被其他用户执行的时候，会被赋予命令所有者的权限，如passwd命令的所有者是root,如果被设置了SUID位，那么其他用户在执行该命令的时候，该命令会有root的权限。而SGID则是执行命令的人拥有了该命令所属组的权限。或者按照书中的说法来说，SUID位告诉内核，运行这个程序的时候认为是由这个文件所有者在运行这个程序。sticky位作用在文件程序上，表示即使没有人在使用该程序，也要把他放在交换空间中。而sticky作用在目录上，则表示，该目录里的文件只能由创建者来删除，如/tmp目录。
14. 一个文件的权限通过9位表示，其中前3位是文件所有者的权限，而不是当前登录用户的权限。
15. 在创建文件的时候，需要填入文件的9位权限，即rwxrwxrwx的这些权限，但是传入的权限，并不是文件生成后最终的权限，最终的权限需要经过系统里的掩码处理，这个掩码就是系统里的umask，一般为022,022表示删除group和other的w权限，即在创建文件的时候即使用户想要group和other有对文件的写权限，但经过umask掩码创建完毕后，group和other都不会有写权限。
16. 文件通常包含3个时间，创建时间，最后访问时间，最后修改时间，通过touch命令，可以修改文件的最后访问时间和最后修改时间。
17. 文件系统分为3个区，分别是超级块、i-节点表、数据区。超级块存储文件系统本身的信息，如每个区域的大小。i-节表中的inode记录文件的一些属性如文件大小，文件所有者，最后访问时间等，每个i节点的大小相等，而i-节点表实际上就是一个列表,如inode0就是列表中的第一个数据，文件系统中每个文件都拥有一个inode.数据区里存放文件的内容，数据区里每个块大小都一样，如果一个文件超过一个块的大小，就会分配到其他块里。
18. inode节点存放了文件内容存放的块位置。创建文件后，会将文件的inode和文件名存放在文件目录系统中。文件目录是一个包含了文件名字列表的特殊文件，包含inode和文件名的表。多重连接的inode是相同的，指向同一个文件， =.= 的i节点就是pwd目录的i节点。
19. cat的工作流程是首先找到文件的inode,在inode表中找到其中的块位置，并进行读取。
20. 一个大文件在存储的时候，i节点中记录的数据块数可能过大，存储不了，而此时i节点存储块位置的方式就是前n个存储常规的块位置信息，剩下的数据块则存放在一个单独的数据块中，并用i节点关联。
21. link的inode是相同的。而link -s的inode是不同的，但是都是像操作同一个文件。
22. 装载是将一个磁盘装载到文件系统的某个目录上，比如/目录装载了磁盘1，而/home则装载了磁盘2，那么从/到/home则进入了不同的文件系统。 不同的文件系统不同的文件可能有相同的inode节点值。
23. 在unix系统中，每个设备都被当作是一个文件，每个设备都有一个文件名，一个inode,一个文件所有者，一个权限位的集合以及修改时间。与文件相关的属性，也被应用到终端以及其他设备(如/dev/mouse*是鼠标，/dev/dsp*是声卡文件)。一个键盘，一个打印机都可以被认为是终端，一个telnet或ssh的窗口也被认为是终端。
24. 存放设备的文件存放在目录/dev中，但是可以在任何目录中创建设备文件
25. 可以通过系统调用(open,read)等来读取设备中的数据。终端支持read和write,但不支持lseek。
26. 使用tty来显示当前终端的文件，如ssh登录到一台设备后，使用tty显示 =/dev/pts/2= 那么使用 =echo haha > /dev/pts/2= 就会将haha显示到当前的终端窗口上。同理，你可以使用root权限，来像 =/dev/pts/2= 的终端窗口来发送数据。
27. 设备文件的inode节点存储的是指向内核子程序的指针，而不是文件大小和存储列表。内核中传输设备数据的子程序被称为设备驱动。
28. 设备文件的权限写，表示是否有权限向设备中发送数据，而权限读是从设备中读取数据。
29. 目录中存放的是i节点和文件名，i节点中有一个变量来标识i节点的类型,如文件类型，还是设备类型等等。
30. 磁盘文件和设备文件有相似之处，也有不同之处，两者都有一些特有的属性。
31. 文件描述符有很多模式，如O_APPEND,O_SYNC等。可以通过fcntl来给文件描述符来设置相应的模式
32. 终端对应的文件描述符也有很多设置，比如stty就是显示终端的文件描述符对应的设置，可以使用 =stty --all= 显示所有设置。如eof=^D，就表示Ctrl+D 输入了eof。其中一些命令前有减号，表示关闭相应的设置，如 =-olcuc= 表示输出时将小写转换为大写被禁止。可以使用stty来修改相应的设置，如 =stty erase X= 表示使用X键来表示删除.有时候经常会不小心按到 =ctrl+s= 就会出现终端卡死的现象，可以将其命令修改成其他的，如 =stty stop ^P= 这样只有 =ctrl+p= 才会使终端stop.抽空可以详细了解下，里面很多有趣的东东。
33. 终端的缓冲区其实就是输入字符的时候，如果没遇到回车，不会将这些字符发送给程序。这些字符其实就是保存在了缓冲区中。
34. 在用shell并发的时候，会用到文件描述符，如&128,就是128对应的文件描述符，默认情况下使用read方法来读取文件描述符中的内容的时候，会进行阻塞，所以可以通过这个特性，来实现n个程序并发的功能。但是也可以通过文件描述符的相关属性，来关闭这种阻塞(O_NDELAY),这样在读取的时候，如果没有内容则直接返回0.
35. 信号是内核产生的，信号可以被程序忽略和捕捉，但是有两种信号是不能被程序忽略和捕捉,这样可以达到程序可以通过其他方式强制退出，防止其一直运行。
36. 程序计时器有3种，一种是真实时间(所有时间)，一种是用户态时间(虚拟)，一种是用户态加内核态时间(实用)
37. 程序在处理多信号的时候有多种选择，不同的系统处理多信号的情况不大相同，遇到新的信号可能会阻塞，也可能是直接处理该信号，处理完后再回到原信号(递归)。一般递归的处理信号要求函数是可重入的(递归调用不会出现错误)。处理信号的时候可以忽略，也可以调用相关函数来执行等等。POSIX接口就是使用广泛的信号处理模型，其兼容了老版本的信号处理模型，并能设置一些相关设置，如哪些信号是可以阻塞的等等。
38. 一段修改一个数据结构的代码如果在运行时被打断将导致数据的不完整或损毁，则称这段代码为临界区。程序在处理信号的时候，必须决定哪段代码为临界区，然后设法保护这段代码。保护临界区最简单的办法就是阻塞或者忽略那些处理函数将要使用或修改特定数据的信号。
39. 有些进程与一个终端想连，使用ps的时候第二列就是显示的对应终端。如果没有选项，ps就是列吃当前终端运行的程序，而ps -a则列出所有终端运行的程序。-l打印更多的细节，其中S列是程序的状态，值为R为运行，S是sleep睡眠，UID为进程的所属用户的id,pid是该进程的id,ppid是该进程的父进程的id,PRI是进程的优先级，SZ是进程的内存大小等。-f选项可以让ps输出格式化，便于阅读。
40. 进程和文件的保存相似，进程也有一个内存页面，来保存其进程分配到内存的位置。
41. shell在执行程序的时候会创建一个新的进程执行，并等待这个进程执行结束。方法就是通过fork(创建一个新的进程)、execvp(用来运行相关程序，如ls)、以及父进程(shell)等待子进程(要运行的程序)(通过wait/exit来实现)
42. 在使用execvp来创建进程并执行相关的shell命令的时候，会将原进程的命令清除，并用新的进程指令代替，所以原进程后续的输出均不会被打印。
43. shell中的if语句后边可以跟命令，如果命令执行成功且有结果，返回值是0，如果执行失败则返回值非0.如grep some tmp.txt找存在some的行，如果没找到，返回的是1，即不成功，可以利用这些特性，和if进行组合操作.如果if后有一系列的命令，那么最后一个命令才会被当做条件判断。
44. set命令是列出当前shell定义的所有变量。shell是一个进程，使用export导出一个变量的时候，该进程及其子进程都可以使用到该变量，或者说该登录的该shell一直可以使用到该变量。而不使用export导出时，其实就是正常的变量赋值,该变量就是局部变量。或者说export就是把一个局部变量添加到该进程环境中。
45. 三个标准输入输出文件描述符都是特殊的文件描述符.大步分unix程序都是从文件或标准输入读取数据，若给了文件名，则从文件中读数据，若没给，则从标准输入读数据，所以你可以测试一下cat命令，不给文件，那么就会读取标准输入。
46. 使用>来重定向，其实是对shell进行的，当你执行cat file > file2时，shell将输出重定向到文件file2中。而程序并不关心你的输出放在哪。重定向是你的shell做的事。
47. 三个基本的重定向操作：1. who>userlist,将stdout连接到一个文件 2. sort < date, 将stdin连接到一个文件。3. who | sort 将stdout和stdin连接。
48. 每个进程都保存一个文件描述符的数组，其中一般012都被分配给了终端的stdin,stdout,sdterr的连接,再次分配时，都会先分配当前数组中可用的最小位置。
49. 将stdin连接到文件有以下几种方法。1. close-then-open,即先关闭文件描述符0,再打开文件，因为分配最低位置，所以会将0描述符分配给该文件。2.open-close-dup-close,先打开文件，分配一个描述符，再关闭0,再复制一份，此时复制的分配了0 ，再把之前的关闭。
