<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-07-20 Sat 10:26 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>关于协程</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="qxg" />
<link rel="shortcut icon" type="image/x-icon" href="/static/img/favicon.ico">
<link rel="stylesheet" type="text/css" href="/static/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="/static/css/readtheorg.css"/><link rel="stylesheet" type="text/css" href="/static/css/orgstyle.css"/>
<script src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/twitter-bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="/static/js/readtheorg.js"></script>
<script type="text/javascript" src="/static/js/orgscript.js"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="/index.html"> UP </a>
 |
 <a accesskey="H" href="/index.html"> HOME </a>
</div><div id="content">
<h1 class="title">关于协程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org95773a7">概述</a></li>
<li><a href="#orgd7962a8">什么是协程</a></li>
<li><a href="#org76d6bf6">参考</a></li>
</ul>
</div>
</div>

<div id="outline-container-org95773a7" class="outline-2">
<h2 id="org95773a7">概述</h2>
<div class="outline-text-2" id="text-org95773a7">
<p>
在学了golang后，很喜欢其中的协程goroutine,对其实现方式也很有兴趣，经常思考，一个cpu内核开一个线程，是怎么对这些个协程进行调度的，所以去看了下源码，发现并不是很容易看懂，网上搜了很多文章，也不知其所以然，所以就又去看async/await的实现方法，在看async之前，一直以为协程就是轻量级线程，类似golang中的那样，但是看过async之后，总觉得async的用法怪怪得，跟golang的goroutine完全不一样，后来才发现是自己的理解有问题。
</p>
</div>
</div>
<div id="outline-container-orgd7962a8" class="outline-2">
<h2 id="orgd7962a8">什么是协程</h2>
<div class="outline-text-2" id="text-orgd7962a8">
<p>
协程是轻量级线程，其调度是在用户态完成的，及不是内核态或者说不是操作系统自己做的调度。
这里可以简单记录下三者的区别,首先有知道进程的调度是跟时间片有关的，这个是os关心的事情，只要知道os做了很多,进程很难被饿死就对了。不要限入了，某个进程会一直执行的思维里去了。
</p>
<ol class="org-ol">
<li>进程是在调度的时候必须进入内核态，其由操作系统进行调度，其有独立的上下文(PCB,process control blcok)，保存当前进程执行的上下文环境，有独立的地址空间，在调度的时候切换上下文会占用资源，所以其调度的花费时间较长。</li>
<li>线程是轻量级进程，一个进程里可以有多个线程，且共享该进程中的所有资源，每个线程又有自己的执行堆栈等信息，但没有独立的地址空间，线程在调度的时候切换上下文环境开销比进程小。</li>
<li>线程通常也分为用户线程和内核线程，内核线程通常是内核自己创建出来的线程，也叫守护线程，但内核线程只工作在内核态，没有用户空间，</li>
<li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程(main),线程是进程里的一个执行单元,也是进程内的可调度的实体。一个线程挂掉，将导致整个进程挂掉。</li>
<li>进程间通信需要通过IPC的方式，此种方式有很多，如管道，信号量等，而同一进程下的线程通信可以通过共享变量等手段.</li>
<li>协程是由用户态线程进行调度。其核心思想 <b><b>控制流的主动让出和恢复</b></b> (yield,await等),必须在单线程中运行。golang中的gorotine其实严格来说并不是协程，而是另一种线程。</li>
<li>一般来说协程分为无栈协程(stackless)和有栈协程(stackful)，如python中的aysnc/await就属于无栈协程，而golang中的go func属于有栈协程。有栈其实就是在调度的时候将栈中的内容全部保存下来，所以可以将其看成另一种线程,或者用户态线程。</li>
</ol>

<p>
我自己还纳闷，golang里，一个线程里不开辟新的空间，不替换寄存器的时候，单条流运行到底是怎么实现多个协程的调度的，现在算是明白了一点。
</p>
</div>
</div>

<div id="outline-container-org76d6bf6" class="outline-2">
<h2 id="org76d6bf6">参考</h2>
<div class="outline-text-2" id="text-org76d6bf6">
<p>
<a href="https://jiajunhuang.com/articles/2018_04_03-coroutine.md.html">https://jiajunhuang.com/articles/2018_04_03-coroutine.md.html</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: qxg</p>
<p class="date">Created: 2019-07-20 Sat 10:26</p>
<p class="validation"></p>
</div>
</body>
</html>
