<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-12-06 Fri 15:41 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>关于协程</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="qxg" />
<link rel="shortcut icon" type="image/x-icon" href="/static/img/favicon.ico">
<link rel="stylesheet" type="text/css" href="/static/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="/static/css/readtheorg.css"/><link rel="stylesheet" type="text/css" href="/static/css/orgstyle.css"/>
<script src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/twitter-bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="/static/js/readtheorg.js"></script>
<script type="text/javascript" src="/static/js/orgscript.js"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="/index.html"> UP </a>
 |
 <a accesskey="H" href="/index.html"> HOME </a>
</div><div id="content">
<h1 class="title">关于协程</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org95773a7">概述</a></li>
<li><a href="#orgd7962a8">什么是协程</a></li>
<li><a href="#orgf0002ca">为什么协程比线程快</a></li>
<li><a href="#org76d6bf6">参考</a></li>
</ul>
</div>
</div>

<div id="outline-container-org95773a7" class="outline-2">
<h2 id="org95773a7">概述</h2>
<div class="outline-text-2" id="text-org95773a7">
<p>
在学了golang后，很喜欢其中的协程goroutine,对其实现方式也很有兴趣，经常思考，一个cpu内核开一个线程，是怎么对这些个协程进行调度的，所以去看了下源码，发现并不是很容易看懂，网上搜了很多文章，也不知其所以然，所以就又去看async/await的实现方法，在看async之前，一直以为协程就是轻量级线程，类似golang中的那样，但是看过async之后，总觉得async的用法怪怪得，跟golang的goroutine完全不一样，后来才发现是自己的理解有问题。
</p>
</div>
</div>
<div id="outline-container-orgd7962a8" class="outline-2">
<h2 id="orgd7962a8">什么是协程</h2>
<div class="outline-text-2" id="text-orgd7962a8">
<p>
协程是轻量级线程，其调度是在用户态完成的，即不是内核态或者说不是操作系统自己做的调度。
这里可以简单记录下三者的区别,首先有知道进程的调度是跟时间片有关的，这个是os关心的事情，只要知道os做了很多,进程很难被饿死就对了。不要限入了，某个进程会一直执行的思维里去了。
</p>
<ul class="org-ul">
<li>进程是在调度的时候必须进入内核态，其由操作系统进行调度，其有独立的上下文(PCB,process control blcok)，保存当前进程执行的上下文环境，有独立的地址空间，在调度的时候切换上下文会占用资源，所以其调度的花费时间较长。</li>
<li>线程是轻量级进程，一个进程里可以有多个线程，且共享该进程中的所有资源，每个线程又有自己的执行堆栈等信息，但没有独立的地址空间，线程在调度的时候切换上下文环境开销比进程小。</li>
<li>线程通常也分为用户线程和内核线程，内核线程通常是内核自己创建出来的线程，也叫守护线程，但内核线程只工作在内核态，没有用户空间，</li>
<li>进程是资源分配的最小单位，线程是程序执行的最小单位。</li>
<li>一个程序至少有一个进程，一个进程至少有一个线程(main),线程是进程里的一个执行单元,也是进程内的可调度的实体。一个线程挂掉，将导致整个进程挂掉。</li>
<li>进程间通信需要通过IPC的方式，此种方式有很多，如管道，信号量等，而同一进程下的线程通信可以通过共享变量等手段.</li>
<li>协程是由用户态线程进行调度。其核心思想 <b><b>控制流的主动让出和恢复</b></b> (yield,await等),必须在单线程中运行。golang中的gorotine其实严格来说并不是协程，而是另一种线程。</li>
<li>一般来说协程分为无栈协程(stackless)和有栈协程(stackful)，如python中的aysnc/await就属于无栈协程，而golang中的go func属于有栈协程。有栈其实就是在调度的时候将栈中的内容全部保存下来，所以可以将其看成另一种线程,或者用户态线程。</li>
<li>协程的含义是协作式调度，而golang的新版本的goroutine是通过抢占式调度实现的，所以严格意义上来说，goroutine不能叫做协程。</li>
<li>为什么golang里的协程可以支持数以万记的并发，原因在于golang里的协程内存分配只需4~5kb(动态增长)，而在java中，jvm将线程委托给操作系统，每个线程的内存分配基本上是固定的(可配的),在64位系统中，jvm默认需要为一个线程分配1MB的内存空间,如果将默认值变小，则需要冒堆栈溢出的风险。所以协程可以分配的很多，且上下文切换时间也会相应的有所节省。上述是一个原因，还有一个原因是上下文切换，在java中线程的上下文切换需要从用户态切换到内核态并进行上下文切换，通常耗时1~100us.在一个时钟为10us的cpu单核环境下，保证每个线程1s运行一次，那么1s内最多可运行100k个线程(按调度时间100us),而在golang中的协程不需要到内核态调度，所以几乎没有上下文切换的时间消耗。参考:<a href="https://rcoh.me/posts/why-you-can-have-a-million-go-routines-but-only-1000-java-threads/">https://rcoh.me/posts/why-you-can-have-a-million-go-routines-but-only-1000-java-threads/</a> 讲的很好</li>
<li>单线程中的async为什么比单线程sync优，原因在于单线程sync在执行io操作(即不占用cpu的任务)，或网络操作时，会阻塞，而async可以执行另外的代码，不发生阻塞，所以async要比sync快，但是如果所有的代码都是关于cpu的，不发生阻塞，那么使用sync是比async优的，所以其面向的场景并不同。</li>
</ul>

<p>
我自己还纳闷，golang里，一个线程里不开辟新的空间，不替换寄存器的时候，单条流运行到底是怎么实现多个协程的调度的，现在算是明白了一点。
</p>
</div>
</div>
<div id="outline-container-orgf0002ca" class="outline-2">
<h2 id="orgf0002ca">为什么协程比线程快</h2>
<div class="outline-text-2" id="text-orgf0002ca">
<p>
考虑微观情况，在单核的cpu下，同一时间只有一个程序在运行。那么在多线程的情况下，这些线程串行完成任务和并行完成任务并没有什么区别，但为什么并行的就是比串行完成任务快呢。同样的道理，为什么在大多数情况下协程比线程快呢。
其实，相对来说运行速度 协程&gt;线程&gt;进程 快的原因在于调度，多进程运行的时候，其调度的时候会进行上下文切换，进程的上下文切换会先进入内核态，用户态到内核态的切换会消耗时间，而上下文切换(内存，pcb,栈等等)更会消耗时间。而线程的上下文切换却比进程小很多，虽然其也会进入到内核态，但是因为同进程下的线程间共享内存及其他内容，所以其切换的时间是小于进程的。同样的，协程因为是轻量级线程，其主要主旨是 <b><b>控制流的主动让出和恢复</b></b>,所以协程在运行的时候，其发生的调度的机率比较小，原因在于遇到一些阻塞的情况，会主动让出资源，不发生(内核)调度，再有协程是用户态线程，所以协程的调度是在用户态进行的，不会切换到内核态， 所以他相对线程来说，节约的是用户态到内核态及上下文切换的时间.
</p>
</div>
</div>
<div id="outline-container-org76d6bf6" class="outline-2">
<h2 id="org76d6bf6">参考</h2>
<div class="outline-text-2" id="text-org76d6bf6">
<p>
<a href="https://jiajunhuang.com/articles/2018_04_03-coroutine.md.html">https://jiajunhuang.com/articles/2018_04_03-coroutine.md.html</a>
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: qxg</p>
<p class="date">Created: 2019-12-06 Fri 15:41</p>
<p class="validation"></p>
</div>
</body>
</html>
