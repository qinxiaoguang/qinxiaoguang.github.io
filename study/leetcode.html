<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-08-18 Sun 11:23 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>leetcode题解</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="qxg" />
<link rel="shortcut icon" type="image/x-icon" href="/static/img/favicon.ico">
<link rel="stylesheet" type="text/css" href="/static/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="/static/css/readtheorg.css"/><link rel="stylesheet" type="text/css" href="/static/css/orgstyle.css"/>
<script src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/twitter-bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="/static/js/readtheorg.js"></script>
<script type="text/javascript" src="/static/js/orgscript.js"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="/index.html"> UP </a>
 |
 <a accesskey="H" href="/index.html"> HOME </a>
</div><div id="content">
<h1 class="title">leetcode题解</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org33903dd">概述</a></li>
<li><a href="#org40afaa7">0002</a></li>
<li><a href="#orgf548fd5">0003</a></li>
<li><a href="#orgfb2a32b">0004</a></li>
<li><a href="#org5ebf8c8">0005</a></li>
<li><a href="#org286426f">0006</a></li>
<li><a href="#orge0421f6">0010</a></li>
<li><a href="#orgbfbc17f">0011</a></li>
<li><a href="#orgb4958ad">0014</a></li>
<li><a href="#org963b940">0015</a></li>
</ul>
</div>
</div>
<div id="outline-container-org33903dd" class="outline-2">
<h2 id="org33903dd">概述</h2>
<div class="outline-text-2" id="text-org33903dd">
<p>
过于简单的题，就不记录了
</p>
</div>
</div>
<div id="outline-container-org40afaa7" class="outline-2">
<h2 id="org40afaa7">0002</h2>
<div class="outline-text-2" id="text-org40afaa7">
<p>
题目大意
</p>
<p class="verse">
计算两个链表的和，如1-&gt;2-&gt;3 + 2-&gt;4-&gt;6 = 3-&gt;6-&gt;9<br />
</p>

<p>
解决要点
</p>
<p class="verse">
使用一个临时变量来保存其中的进位<br />
</p>
</div>
</div>

<div id="outline-container-orgf548fd5" class="outline-2">
<h2 id="orgf548fd5">0003</h2>
<div class="outline-text-2" id="text-orgf548fd5">
<p>
题目大意
</p>
<p class="verse">
字符串中的最长无重复子串，如abcbcaa ,最长无重复子串是 abc<br />
</p>

<p>
解决要点
</p>
<p class="verse">
使用start,end两个指针来进行遍历，遍历的时候，只需要end依次往后移动，start不动，同时需要使用一个hashmap来记录当前最后一个出现的字母的位置，如abcb,遍利到c时，hashmap中的值是[a]=0,[b]=1,[c]=2,那么在每次遍利的时候，都要查询hashmap中是否存在当前字母，如果存在，则计算目前遍利的最长子串的长度，并将start放在当前位置，end继续往后遍历，同时更新hashmap中出现的重复的字母的位置。这样整个时间复杂度为o(n)。<br />
</p>
</div>
</div>
<div id="outline-container-orgfb2a32b" class="outline-2">
<h2 id="orgfb2a32b">0004</h2>
<div class="outline-text-2" id="text-orgfb2a32b">
<p>
题目大意
</p>
<p class="verse">
有两个有序数组，求这两个有序数组的中位数，如果中位数有两个，则求这两个数的平均。如: [1,2], [3]的中位数是2, [1,2],[3,4]的中位数是 (2+3)/2 = 2,要求时间复杂度是log(m+n)<br />
</p>

<p>
解决要点
</p>
<p class="verse">
题中要求时间复杂度是log(m+n)所以其一定是使用二分的方法进行解决，该题的主旨是求第k大的数，其中k=(m+n)/2,比较两个中位数的大小，假设第一个数组的中位数小于第二个数组的中位数，如果当前两个数组的总长度-第一个数组到中位数的长度 依然比k大，那么第k大的数就一定不在第一个数组的中位数左边的数中，所以可以将第一个数组中位数左边的数排除掉，依次类推。<br />
</p>
</div>
</div>

<div id="outline-container-org5ebf8c8" class="outline-2">
<h2 id="org5ebf8c8">0005</h2>
<div class="outline-text-2" id="text-org5ebf8c8">
<p>
求最大回文子串
解:
</p>
<p class="verse">
1. 暴力,从每个串的中心往两边遍历。计算最大值。但是如果是偶数个数，就需要在每两个数之间填充一个字符。为了方便，无论是奇数还是偶数，都往其填字符,无论两个数之间还是两边，都填相同的字符，这样最终的字符串一定是奇数个，如 123 -&gt; #1#2#3# ， 1234 -&gt; #1#2#3#4#。时间复杂度O(n^2)<br />
2. dp, 注意不要把其类比为两个字符串的最大公共子串，完全不相关！使用dp的方式为，若dp[i][j]为回文串，那么dp[i+1][j-1]也是回文, 所以有，~if s[i] <code>= s[j] : dp[i][j] =</code> (true &amp;&amp; dp[i+1][j-1])~  时间复杂度O(n^2)<br />
3. Manacher方法,与第一种方法类似，从中心点遍历，但是该方法的要点是利用到之前已经得到的回文串信息进行遍历，设rl[i]为当前点最大回文半径，回文半径就是以当前点为中心的回文长度的一半+1,那么这个问题就是求rl[i]的所有值，那么如何求rl[i]呢，假设当前遍历到了i点，并设mx为当前知道的所有回文串中最靠右的串(不是最大回文串)，而mid则是最靠右的回文串的中心点。那么如果i&gt;=mx,则只能从中心往外扩展，而若i&lt;mx,则可以使用到i关于mid的对称点(j)的信息，因为rl[j]的值已经求出，那么rl[i]&gt;=r[j],如果i到mx的长度大于r[j]则，必然有r[i]=r[j],否则在r[j]的基础上继续向外边扩展。<br />
</p>
<p>
manacher方法参考:<a href="https://segmentfault.com/a/1190000003914228">https://segmentfault.com/a/1190000003914228</a> 、<a href="https://www.felix021.com/blog/read.php?2040">https://www.felix021.com/blog/read.php?2040</a>
</p>
</div>
</div>
<div id="outline-container-org286426f" class="outline-2">
<h2 id="org286426f">0006</h2>
<div class="outline-text-2" id="text-org286426f">
<p>
求zigzag的水平方向字符串。
如:
</p>
<p class="verse">
"abcdefghijklmn"的zigzag图如下<br />
a    g    m<br />
b  f h  l n<br />
c e  i k<br />
d    j<br />
那么他的水平方向字符串为: "agmbfhlnceikdj"<br />
</p>
<p>
解:
</p>
<p class="verse">
其实把字符串的下标写出来:<br />
1     7       13<br />
2   6 8    12 14<br />
3 5   9  11<br />
4     10<br />
是可以发现其中的规律的。<br />
假设有n行，那么第i行的水平字符串的规律为: prefix+ 2*(n-i) 或 prefix + 2*(i-1),其实就是交替加上数值2*(n-i)和2*(i-1),但是要注意，如果n-i或者i-1为0，则跳过。<br />
</p>
</div>
</div>
<div id="outline-container-orge0421f6" class="outline-2">
<h2 id="orge0421f6">0010</h2>
<div class="outline-text-2" id="text-orge0421f6">
<p>
模仿正则的题，输入的正则匹配串只有a-z及 <code>*.</code> ，其中 <code>*</code> 表示匹配0到多个， <code>.</code> 匹配1个
解:
</p>
<p class="verse">
1. 有向状态自动机，采用dfs或者bfs的方式或者递归进行解，但时间复杂度比较大。<br />
2. 二维dp来解:dp[i][j]表示s[0,i)与p[0,j)是否match，那么dp[i][j]的更新规则则为:<br />
- <code>dp[i][j] = dp[i-1][j-1], if p[j-1]!= "*" &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == '.')</code> 如果s[i],p[j]相等，或者p[j]是符号.，则dp[i+1][j+1]=dp[i-1][j-1]<br />
- <code>dp[i][j] = dp[i][j-2], if p[j-1] == "*" and pattern repeats for 0 times</code> 如果当前p点是*符号，并且没有被匹配过，则dp[i+1][j+1]=dp[i+1][j-1]，因为*可以匹配0次。<br />
- <code>dp[i][j] = dp[i-1][j] &amp;&amp; (s[i-1] == p[j-2] || p[j-2] == "."), if p[j-1] == "*" and the pattern repeats for at least 1 times</code> 如果当前点是*且被匹配1次以上，那么dp[i+1][j+1] = dp[i][j+1] &amp;&amp; (s[i]==p[j-1] || p[j-1] = .)<br />
其实大白话就分3种情况，当前点是字母，当前点是.,当前点是*等。<br />
</p>
</div>
</div>
<div id="outline-container-orgbfbc17f" class="outline-2">
<h2 id="orgbfbc17f">0011</h2>
<div class="outline-text-2" id="text-orgbfbc17f">
<p>
给定一个数组，数组中的每个点的数表示该点中线段的高，计算哪两个线段围成的矩形面积最大。数组中每相邻两个点的距离为1
解：
</p>
<p class="verse">
使用i,j两个指针，分别指向数组首尾，并记录当前ij围成的面积是否最大，更新当前面积最大值，若arr[i]&lt;arr[j]，则i右移即i++,否则j&#x2013;.<br />
该题巧妙在，i,j指针中的最小值是面积的极限，所有如果arr[i]&lt;arr[j],移动j没有意义，即(i,j-1)不会比(i,j)大,所有只能移动i来更新面积大小。<br />
</p>
</div>
</div>

<div id="outline-container-orgb4958ad" class="outline-2">
<h2 id="orgb4958ad">0014</h2>
<div class="outline-text-2" id="text-orgb4958ad">
<p>
题目是求多个串的最长公共前缀,如"abc","a","ab"的最长公共前缀是"a"
解:
</p>
<p class="verse">
1. 暴力解，复杂度o(n^2)<br />
2. 看起来此题很简单，但是实际还有更好的解法。先用一个最短的字符串做基准，让他依次与后边的所有串比较，被比较的串截取成与该最短串长度一样，并对比是否相等，若相等，则比较下一个，否则找出这两个串中的最长公共前缀串，方法是暴力，并用他更新当前的基准串。依次类推。该种方法的巧妙之处在于，不是一个字符一个字符的比较，而是多个字符一起比较。<br />
</p>
</div>
</div>
<div id="outline-container-org963b940" class="outline-2">
<h2 id="org963b940">0015</h2>
<div class="outline-text-2" id="text-org963b940">
<p>
找一个数组中所有的3个数加起来等于0的数
解:
</p>
<p class="verse">
1. 暴力解o(n^3),超时<br />
2. 先对数组排序，遍历该数组，遍历到i个数时，即求i后的数组中的两个数加起来等于arr[i]的负数。则题目变为求一个有序数组中加起来等于某数的两个数。解决其问题的思路是使用两个指针(i,j)，分别指向前后，如果两个指针的数加起来比目标值大，则j&#x2013;, 否则i++,原因在于j&#x2013;使得两个数减小，i++使得两个数变大。<br />
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: qxg</p>
<p class="date">Created: 2019-08-18 Sun 11:23</p>
<p class="validation"></p>
</div>
</body>
</html>
