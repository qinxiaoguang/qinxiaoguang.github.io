<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-12-06 Fri 15:40 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>智能指针</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="qxg" />
<link rel="shortcut icon" type="image/x-icon" href="/static/img/favicon.ico">
<link rel="stylesheet" type="text/css" href="/static/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="/static/css/readtheorg.css"/><link rel="stylesheet" type="text/css" href="/static/css/orgstyle.css"/>
<script src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>
<script src="https://cdn.bootcss.com/twitter-bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="/static/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="/static/js/readtheorg.js"></script>
<script type="text/javascript" src="/static/js/orgscript.js"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="/index.html"> UP </a>
 |
 <a accesskey="H" href="/index.html"> HOME </a>
</div><div id="content">
<h1 class="title">智能指针</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org8dc117c">概述</a></li>
<li><a href="#orga435ab8">详述</a></li>
</ul>
</div>
</div>

<div id="outline-container-org8dc117c" class="outline-2">
<h2 id="org8dc117c">概述</h2>
<div class="outline-text-2" id="text-org8dc117c">
<p>
rust中有很多智能指针，如Cell,RefCell,Box,Rc,Arc等等，这些指针的场景还很多，需要弄明白。
</p>
</div>
</div>
<div id="outline-container-orga435ab8" class="outline-2">
<h2 id="orga435ab8">详述</h2>
<div class="outline-text-2" id="text-orga435ab8">
<p>
虽然是智能指针，但是可以不把其当指针用，因为rust中存在deref,所以可以将其当作原类型使用。
对于Cell和RefCell,因为struct中的field中不能使用mut修饰，如果内部的域需要mut属性，可以将struct设置为mut类型，或者使用Cell或者RefCell.
</p>
<ol class="org-ol">
<li>Cell&lt;T&gt;:一个包含一个T类型数据的指针，他唯一特殊的用途是你可以对T(即使是非可变的类型)进行可变(set)操作。相关方法有: <code>Cell::new(value)</code> , <code>cell.get()</code> , <code>cell.set(value)</code> .而Cell本身是不可变，而内部的数据是可变的，这就是内部可变性。cell.set(value)实际上就是将内部对应的值替换掉了,之前的值丢弃掉，所以其value值是mutable，可以看到set的方法声明是这样的: <code>fn set(&amp;self, value:T)</code>. 其内部是通过unsafe来达到内部可变性的。</li>
<li>RefCell&lt;T&gt;:如果T类型不是Copy类型，那么Cell是无法使用的，因为Cell中的get方法返回的是T的copy.而如果一个T不是Copy类型，那么可以使用RefCell&lt;T&gt;，该方法和Cell不同的是，RefCell获取值是通过 ref_cell.borrow()方法，其返回Ref&lt;T&gt;，及获取内部值的引用。而可以通过ref_cell.borrow_mut()获取可变引用,返回RefMut&lt;T&gt;。</li>
<li>Box：在Rust中，对于trait类型是没有固定的长度的，但struct在声明的时候，必须要明确其长度(size),所以假设有 <code>trait A</code>,而 <code>struct B{a:A}</code> 是不被允许的，原因就是在编译时，struct长度就必须明确，而Box是一个智能指针，其作用是直接在堆中分配指向的内容，而智能指针的长度是确定的，所以struct可以这样写 <code>struct B{a:Box&lt;A&gt;}</code></li>
<li>Cow: 写时复制，即Copy On Write,是指如果需要对某个变量进行复制时，系统并不会直接复制，而是使用相同的内存空间，在只读的时候，读取相同的空间，而如果发生了数据的写入时，才会进行复制操作。原因就是如果变量内存很大时，直接复制会占用很大的时间，而如果复制完后并不发生写入，则会浪费资源,多用于读多写少的操作。而Rust中的Cow是一个枚举类型，包含Borrow(T)及Owned(T)。使用Cow::from(xx)来创建一个Cow时，如果xx是引用，对cow做任何操作都不会影响到xx，而xx是值，则xx会被move,对其操作，其实就是更改xx.通俗点说，Cow就是某个数据的克隆体，不过什么时候克隆，需要调用相关方法的时候，才会被决定。</li>
<li>Rc or Arc: 引用记数，Reference Count.第一个Rc是非线程安全的，而Arc是线程安全的，通常用在多线程之间，注意其方法clone()并不会复制内部的数据，只是多了一个对引用记数器进行+1,同样在生命周期结束后，并不会将引用值删除，而是引用数减一。在Rust中一个资源只能拥有一个拥有者，而使用Rc后，一个资源可以有多个拥有者.对于闭包而言，如果传递了一个引用，这个闭包并不知道会在什么时候结束，所以传递一个Rc来说是比较合适的，而多线程的spawn会传递进一个闭包，如果该闭包接受一个引用，同样不知道该线程什么时候结束，那么传递一个Arc引用比较合适,这个时候程序运行就不依赖引用的生命周期了。</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: qxg</p>
<p class="date">Created: 2019-12-06 Fri 15:40</p>
<p class="validation"></p>
</div>
</body>
</html>
